### 一、 针对“设计问题”的决策调整

#### 1\. 关于 Processing 区域

注意，该系统设计底层就是只允许一个任务运行，所以完全没必要考虑多任务运行的情况

#### 2\. 关于动画复杂度 

**方案：简化为 CSS 驱动的“完成即离场”。**

  * **状态变更：** 数据层面收到 `finished`，立即更新 store。
  * **动画逻辑：** 使用 Vue 的 `<TransitionGroup>` 处理列表项的移动，而不是手动计算 JS 动画。
  * **视觉补偿：** 任务卡片增加一个 `.is-newly-finished` 类，保留高亮 1-2 秒（即使它已经移动到了 Finished 列表的顶部），给用户一个“视觉残留”。

#### 3\. 关于折叠性能 (CSS Grid vs Virtual Scroll)

**决策：** 对于 \< 200 个任务，CSS Grid 性能完全没问题。对于 \> 200 个任务（特别是已完成历史），**不应该渲染**。
**方案：**

  * **活跃区域 (Queued/Paused/Failed)：** 使用 CSS Grid 动画。这些列表通常不会过长。
  * **历史区域 (Finished)：** **限制渲染数量**。只渲染最近的 20 条。底部的“查看更多”按钮跳转到独立的“历史记录页”。**不要在监控页引入虚拟滚动**，这会显著增加代码复杂度且收益有限。

-----

### 二、 核心架构代码 (Vue 3 Composition API)

这是结合了你方案 A 和方案 B 优点的最终架构，重点解决了 **数据结构** 和 **SSE 稳定性**。

#### 1\. Store 设计 (UnifiedTaskStore)

采用 **Map (ID索引)** + **Array (排序索引)** 的范式。

```javascript
// stores/taskStore.js
import { defineStore } from 'pinia';
import { computed, ref, reactive } from 'vue';

export const useTaskStore = defineStore('task', () => {
  // 1. 核心数据源 (Normalized Data)
  const tasksMap = reactive(new Map()); // ID -> Task Object
  
  // 2. 顺序索引 (保持单一事实来源)
  const queueOrder = ref([]); // Array<JobId> 严格对应后端顺序

  // 3. 辅助状态
  const sseConnected = ref(false);
  const lastHeartbeat = ref(Date.now());

  // 4. 计算分组 (Getters)
  const processingTasks = computed(() => 
    Array.from(tasksMap.values()).filter(t => t.status === 'processing')
  );

  const queuedTasks = computed(() => {
    // 关键：严格按 queueOrder 排序，找不到 ID 的过滤掉
    return queueOrder.value
      .map(id => tasksMap.value.get(id))
      .filter(t => t && t.status === 'queued');
  });

  // Failed/Paused/Finished 按时间倒序
  const failedTasks = computed(() => 
    Array.from(tasksMap.values())
      .filter(t => t.status === 'failed')
      .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
  );

  // ... Paused similar to Failed ...

  // Finished 只取前 20 条，避免 DOM 爆炸
  const recentFinishedTasks = computed(() => 
    Array.from(tasksMap.values())
      .filter(t => t.status === 'finished')
      .sort((a, b) => new Date(b.completed_at) - new Date(a.completed_at))
      .slice(0, 20)
  );

  // 5. Actions
  function updateTask(task) {
    tasksMap.set(task.job_id, task);
    
    // 如果任务完成了，且不在 finished 列表里（防止重复），前端可以做短暂的高亮标记
    if (task.status === 'finished') {
       // logic to trigger toast or highlight
    }
  }

  // SSE 心跳检测 (解决 SSE 断开无感知问题)
  function checkConnection() {
    if (Date.now() - lastHeartbeat.value > 30000) { // 30s 超时
      sseConnected.value = false;
    }
  }
  
  // 在组件中定期调用 checkConnection 或者设置 setInterval

  return {
    tasksMap,
    queueOrder,
    processingTasks,
    queuedTasks,
    failedTasks,
    recentFinishedTasks,
    sseConnected,
    updateTask,
    // ...
  };
});
```

#### 2\. 组件实现 (TaskMonitor.vue)

```html
<template>
  <div class="flex flex-col h-full bg-gray-50 relative">
    
    <div class="shrink-0 bg-white border-b z-10 shadow-sm">
      <div class="max-h-[300px] overflow-y-auto p-4 space-y-3">
        <TransitionGroup name="list">
          <TaskCard 
            v-for="task in processingTasks" 
            :key="task.job_id" 
            :task="task" 
            class="border-blue-500 ring-1 ring-blue-100"
          />
        </TransitionGroup>
        
        <div v-if="processingTasks.length === 0 && isInitialLoading" class="animate-pulse ...">
          正在初始化...
        </div>
      </div>
    </div>

    <div class="flex-1 overflow-y-auto p-4 pb-20 space-y-4" ref="scrollContainer">
      
      <div v-if="!sseConnected" class="bg-red-50 text-red-600 p-3 rounded-md text-sm flex items-center">
        ⚠️ 实时连接已断开，正在尝试重连...
      </div>

      <TaskGroup 
        title="失败任务" 
        :count="failedTasks.length" 
        variant="danger"
        :default-collapsed="true"
      >
        <TaskCard v-for="task in failedTasks" :key="task.job_id" :task="task" />
      </TaskGroup>

      <TaskGroup 
        title="排队中" 
        :count="queuedTasks.length" 
        variant="primary"
        :default-collapsed="false"
      >
        <Draggable 
          v-model="dragModel" 
          item-key="job_id"
          :animation="200"
          ghost-class="opacity-50"
          handle=".drag-handle"
          :scroll-sensitivity="80" 
          :scroll-speed="20"
          @end="onDragEnd"
        >
          <template #item="{ element }">
             <TaskCard :task="element" is-draggable />
          </template>
        </Draggable>
      </TaskGroup>

      <TaskGroup title="已暂停" :count="pausedTasks.length" :default-collapsed="true">
         </TaskGroup>

      <TaskGroup title="最近完成" :count="recentFinishedTasks.length" variant="success" :default-collapsed="true">
        <TransitionGroup name="list">
           <TaskCard v-for="task in recentFinishedTasks" :key="task.job_id" :task="task" />
        </TransitionGroup>
        <div class="text-center text-xs text-gray-400 mt-2 cursor-pointer">
           查看全部历史记录 >
        </div>
      </TaskGroup>

    </div>

    <div class="absolute bottom-0 left-0 right-0 h-16 bg-gradient-to-t from-gray-50 to-transparent pointer-events-none"></div>

  </div>
</template>

<script setup>
// ... import logic
// 使用 vue.draggable.next (针对 Vue 3)
</script>

<style>
/* 简单而优雅的列表过渡动画 */
.list-move, /* 对移动中的元素应用过渡 */
.list-enter-active,
.list-leave-active {
  transition: all 0.3s ease;
}

.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

/* 确保离开的元素从布局流中移除，以便其他元素可以平滑移动 */
.list-leave-active {
  position: absolute; 
}
</style>
```

-----

### 三、 实施路线图 (Implementation Roadmap)

既然你推荐“增量优化”，我们可以按照你的计划微调，但步骤更明确：

1.  **Step 1: 数据层重构 (Priority: High)**

      * 实现 `UnifiedTaskStore`，剥离 `queueOrder` 和 `tasksMap`。
      * 确保后端 SSE 推送只更新 Map 和 Order，UI 自动响应。
      * **目标：** 数据源单一，逻辑清晰。

2.  **Step 2: 基础布局组件化 (Priority: High)**

      * 创建 `TaskGroup.vue` 组件（实现 CSS Grid 折叠动画）。
      * 重写主界面布局，引入 Fixed Header + Scroll Body。
      * **目标：** 解决“无法折叠”和“排版混乱”的痛点。

3.  **Step 3: 拖动排序集成 (Priority: Medium)**

      * 引入 `vuedraggable` (基于 Sortable.js)。
      * 配置 `scrollSensitivity`。
      * 绑定 Store 的 `queueOrder` action。
      * **目标：** 恢复排序功能，提升手感。

4.  **Step 4: 细节与健壮性 (Priority: Low)**

      * 添加 SSE 心跳检测。
      * 添加底部遮罩。
      * 优化空状态显示。

这种方式既保证了最终效果（接近方案 A），又避免了推翻重来的风险（符合方案 B 的稳健）。