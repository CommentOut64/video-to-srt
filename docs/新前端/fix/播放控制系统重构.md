# 播放控制系统重构

## 重构日期
2025年12月1日

## 问题背景

用户报告了两个持续存在的问题：

### 问题1：空格键无法使用（首次点击波形上半部分后）
- 进入编辑器后，如果首次点击波形区域上半部分，空格键无法切换播放
- 如果首次点击下半部分，空格键可以使用
- 但首次暂停时光标会跳回第一次点击的位置

### 问题2：进度条拖动失效
- 播放时拖动进度条会跳回原位置
- 暂停时拖动后播放也会跳回原位置

## 根本原因分析

### 原架构问题

原来的播放控制分散在多个组件中，各自管理锁状态，导致：

1. **竞态条件**：多个组件都在设置/释放 `isSeeking` 锁
2. **循环依赖**：
   - VideoStage 的 `onTimeUpdate` → 更新 Store
   - VideoStage 的 `watch(currentTime)` → 同步回 video
   - 两者互相触发，形成循环
3. **防抖时机不一致**：各组件的防抖延迟不同，容易产生竞态
4. **焦点管理混乱**：`document.body.focus()` 在某些浏览器中不可靠

### 数据流混乱

```
原架构：
User Action → VideoStage/PlaybackControls/WaveformTimeline
                    ↓                ↓                  ↓
            各自设置 isSeeking，各自更新 Store，各自解锁
                    ↓                ↓                  ↓
                  产生竞态条件和循环更新
```

## 解决方案：统一播放控制器

### 新架构设计

创建 `usePlaybackController` Hook，统一管理：

1. **Seek 锁管理**：支持嵌套锁，自动超时保护
2. **时间同步**：智能防循环，冷却期机制
3. **拖拽操作**：标准化的开始/更新/结束流程
4. **播放控制**：统一的 togglePlay/play/pause 接口

```
新架构：
User Action → PlaybackController
                    ↓
           统一管理锁和时间同步
                    ↓
              Store (单一数据源)
                    ↓
          VideoStage / WaveSurfer (订阅者)
```

### 核心实现

#### 1. 嵌套锁机制

```javascript
// 支持多层锁，必须全部释放才解锁
function acquireSeekLock(reason) {
  seekLockCount.value++
  isSeekLocked.value = true
  projectStore.player.isSeeking = true
  
  // 超时保护：防止锁永久卡住
  setTimeout(() => forceReleaseLock(), 2000)
}

function releaseSeekLock(delay = 0) {
  setTimeout(() => {
    if (--seekLockCount.value === 0) {
      isSeekLocked.value = false
      projectStore.player.isSeeking = false
    }
  }, delay)
}
```

#### 2. 智能时间同步

```javascript
// 从 Video 同步到 Store
function syncTimeFromVideo(videoTime) {
  if (isLocked()) return false
  if (Date.now() - lastVideoUpdateTime < COOLDOWN) return false
  if (Math.abs(videoTime - storeTime) < THRESHOLD) return false
  
  projectStore.player.currentTime = videoTime
  lastStoreUpdateTime = Date.now()
  return true
}

// 从 Store 同步到 Video
function syncTimeToVideo(storeTime, force = false) {
  if (!force && isLocked()) return false
  if (!force && Date.now() - lastStoreUpdateTime < COOLDOWN) return false
  
  video.currentTime = storeTime
  lastVideoUpdateTime = Date.now()
  return true
}
```

#### 3. 标准化拖拽流程

```javascript
// 开始拖拽
function startDragging(source) {
  acquireSeekLock(`drag:${source}`)
}

// 拖拽中
function updateDragging(time) {
  projectStore.player.currentTime = clampedTime
  syncTimeToVideo(clampedTime, true)  // 强制同步
}

// 结束拖拽
function stopDragging(releaseDelay = 100) {
  releaseSeekLock(releaseDelay)
}
```

### 焦点管理修复

```javascript
// 问题：document.body.focus() 不可靠
// 解决：使用有 tabindex 的容器元素

// 模板
<div class="waveform-timeline" ref="containerRef" tabindex="-1">

// 点击处理
function handleUpperZoneMouseDown(e) {
  e.preventDefault()
  e.stopPropagation()
  
  // 将焦点转移到可聚焦的容器
  if (containerRef.value) {
    containerRef.value.focus()
  }
  
  // ...其他逻辑
}
```

## 组件改造

### VideoStage

```diff
+ import { usePlaybackController } from '@/hooks/usePlaybackController'

+ const playbackController = usePlaybackController({
+   videoRef,
+   componentName: 'VideoStage'
+ })

// watch currentTime
- if (projectStore.player.isSeeking) { ... }
- if (now - lastSyncTime.value < 300) return
+ playbackController.syncTimeToVideo(newTime)

// onTimeUpdate
- if (projectStore.player.isSeeking) return
- debouncedTimeUpdate(video.currentTime)
+ playbackController.handleTimeUpdate(video.currentTime)

// onSeeking / onSeeked
- projectStore.player.isSeeking = true/false
+ playbackController.handleVideoSeeking()
+ playbackController.handleVideoSeeked()
```

### PlaybackControls

```diff
+ import { useSimplePlaybackController } from '@/hooks/usePlaybackController'

+ const playbackController = useSimplePlaybackController('PlaybackControls')

// startDrag
- isDragging.value = true
- projectStore.player.isSeeking = true
+ playbackController.startDragging('progressBar')

// onDrag
- projectStore.seekTo(newTime)
+ playbackController.updateDragging(newTime)

// stopDrag
- isDragging.value = false
- setTimeout(() => projectStore.player.isSeeking = false, 150)
+ playbackController.stopDragging()
```

### WaveformTimeline

```diff
+ import { useSimplePlaybackController } from '@/hooks/usePlaybackController'

+ const playbackController = useSimplePlaybackController('WaveformTimeline')

// 模板：添加 tabindex
- <div class="waveform-timeline" ref="containerRef">
+ <div class="waveform-timeline" ref="containerRef" tabindex="-1">

// handleUpperZoneMouseDown
- document.body.focus()
+ containerRef.value.focus()

- projectStore.player.isSeeking = true
- projectStore.seekTo(clickTime)
+ playbackController.startDragging('waveformCursor')
+ playbackController.updateDragging(clickTime)

// handleCursorDragEnd
- setTimeout(() => projectStore.player.isSeeking = false, 150)
+ playbackController.stopDragging()
```

## 测试用例

### 空格键测试
1. 进入编辑器
2. 点击波形上半部分任意位置
3. 按空格键 → 应立即切换播放状态
4. 再按空格键 → 应立即暂停，光标不跳动

### 进度条拖动测试
1. 播放视频
2. 拖动底部进度条 → 进度应跟随拖动，不跳回
3. 暂停视频
4. 拖动进度条 → 进度应跟随拖动
5. 点击播放 → 应从拖动位置继续播放

### 波形拖动测试
1. 点击波形光标附近，拖动 → 光标应跟随
2. 释放 → 视频应在释放位置
3. 播放 → 应从该位置播放

### 综合测试
1. 快速连续操作：波形点击 → 空格 → 进度条拖动 → 空格
2. 所有操作应流畅，无异常跳动

## 架构优势

1. **单一职责**：PlaybackController 统一管理播放控制
2. **清晰数据流**：User → Controller → Store → Components
3. **可预测行为**：嵌套锁机制确保锁的正确释放
4. **容错机制**：超时自动释放、冷却期保护
5. **易于调试**：统一的日志输出

## 文件清单

- `frontend/src/hooks/usePlaybackController.js` - 新增
- `frontend/src/components/editor/VideoStage/index.vue` - 修改
- `frontend/src/components/editor/PlaybackControls/index.vue` - 修改
- `frontend/src/components/editor/WaveformTimeline/index.vue` - 修改

---

**重构完成时间**：2025年12月1日
