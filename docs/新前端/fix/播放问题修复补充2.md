# 视频播放器问题修复补充 (第二轮)

## 修复日期
2025年12月1日

## 问题背景

在完成了《播放问题修复补充.md》中的修复后，用户报告仍存在两个问题：
1. 空格键依然无法在每次加载编辑器后的第一次波形区域定位后响应
2. 播放视频时拖动进度条，会导致跳回原进度点

## 深度调查结果

### 发现的根本问题

#### 问题核心：WaveformTimeline 光标拖拽时 isSeeking 锁没有正确保持

在 `WaveformTimeline/index.vue` 的 `handleUpperZoneMouseDown` 函数中：

**修复前的代码问题**：
```javascript
if (canDrag) {
    isDraggingCursor.value = true;
    projectStore.player.isSeeking = true  // 设置锁
    projectStore.seekTo(clickTime);
    
    document.addEventListener("mousemove", handleCursorDragMove);
    document.addEventListener("mouseup", handleCursorDragEnd);

    setTimeout(() => {
      projectStore.player.isSeeking = false  // ❌ 200ms后立即解锁
    }, 200)
}
```

**问题分析**：
1. 用户开始拖拽光标 → 设置 `isSeeking = true`
2. **200ms 后**：锁被解除 → `isSeeking = false`
3. 用户仍在拖拽 → `handleCursorDragMove` 持续更新时间
4. 此时 `isSeeking` 已经是 `false`，VideoStage 的 watch 和 onTimeUpdate 不再被阻止
5. 导致竞态条件，进度条跳回

同时 `handleCursorDragEnd` 也没有在拖拽结束后正确解锁。

## 修复方案

### 修复1：WaveformTimeline 拖拽锁管理

**文件**：`frontend/src/components/editor/WaveformTimeline/index.vue`

**修改1.1**：`handleUpperZoneMouseDown` 函数 - 拖拽模式下不要提前解锁

```javascript
if (canDrag) {
    isDraggingCursor.value = true;
    projectStore.player.isSeeking = true  // 设置全局锁，拖拽期间保持锁定
    projectStore.seekTo(clickTime);

    document.addEventListener("mousemove", handleCursorDragMove);
    document.addEventListener("mouseup", handleCursorDragEnd);
    // 【关键修复】拖拽模式下不要在这里解锁，等 handleCursorDragEnd 解锁
} else {
    // 单击跳转（非拖拽）
    projectStore.player.isSeeking = true
    projectStore.seekTo(clickTime);

    // 单击模式下延迟解锁
    setTimeout(() => {
      projectStore.player.isSeeking = false
    }, 200)
}
```

**修改1.2**：`handleCursorDragEnd` 函数 - 拖拽结束后正确解锁

```javascript
function handleCursorDragEnd() {
  isDraggingCursor.value = false;

  document.removeEventListener("mousemove", handleCursorDragMove);
  document.removeEventListener("mouseup", handleCursorDragEnd);

  // 【关键修复】拖拽结束后延迟解锁，确保 video seek 完成
  setTimeout(() => {
    projectStore.player.isSeeking = false;
    console.log('[WaveformTimeline] 光标拖拽结束，isSeeking锁已解除');
  }, 150);
}
```

### 修复2：PlaybackControls 拖拽事件增强

**文件**：`frontend/src/components/editor/PlaybackControls/index.vue`

**修改内容**：`startDrag` 函数添加 `preventDefault`

```javascript
function startDrag(e) {
  e.preventDefault()  // 【增强】阻止默认行为，防止文本选择干扰拖拽
  isDragging.value = true
  projectStore.player.isSeeking = true
  document.addEventListener('mousemove', onDrag)
  document.addEventListener('mouseup', stopDrag)
}
```

## 修复前后对比

### 数据流（修复前）

```
用户拖拽波形光标
    ↓
handleUpperZoneMouseDown: isSeeking = true
    ↓
200ms 后: isSeeking = false  ← ❌ 问题：用户还在拖拽
    ↓
handleCursorDragMove 更新时间
    ↓
VideoStage watch 触发（因为 isSeeking = false）← ❌ 竞态条件
    ↓
video.currentTime 被设置回旧值 → 跳回原点
```

### 数据流（修复后）

```
用户拖拽波形光标
    ↓
handleUpperZoneMouseDown: isSeeking = true
    ↓
handleCursorDragMove 持续更新时间
    ↓
VideoStage watch 检查 isSeeking = true → 跳过（不触发）✅
    ↓
用户释放鼠标
    ↓
handleCursorDragEnd: 延迟 150ms 后 isSeeking = false ✅
    ↓
恢复正常同步
```

## 锁机制一致性

现在三个组件的锁管理逻辑一致：

| 组件 | 锁定时机 | 解锁时机 |
|------|---------|---------|
| **PlaybackControls** | `startDrag` | `stopDrag` + 150ms 延迟 |
| **WaveformTimeline (单击)** | `handleUpperZoneMouseDown` | 200ms 后 |
| **WaveformTimeline (拖拽)** | `handleUpperZoneMouseDown` | `handleCursorDragEnd` + 150ms 延迟 |
| **VideoStage** | `onSeeking` 事件 | `onSeeked` 事件 + 100ms 延迟 |

## 测试建议

### 测试1：波形光标拖拽
1. 播放视频
2. 在波形区域拖拽光标（按住并移动）
3. 预期：视频时间跟随拖拽位置，不跳回

### 测试2：进度条拖拽
1. 播放视频
2. 在底部进度条上拖拽
3. 预期：进度条可顺畅拖动，不跳回

### 测试3：空格键响应
1. 加载编辑器
2. 点击波形区域任意位置
3. 立即按空格键
4. 预期：视频应正常播放/暂停

### 测试4：综合操作
1. 快速连续操作：点击波形 → 按空格键 → 拖动进度条 → 再按空格键
2. 预期：所有操作流畅，无异常行为

## 风险评估

### 低风险
- 修改都是增量式的，只优化了锁的释放时机
- 不影响原有功能，只是完善了边界情况的处理
- 遵循现有架构的锁机制设计

### 需要注意
- 如果用户快速连续操作，锁可能会有短暂的重叠期，但不会导致问题
- 多个组件的锁解除延迟略有不同（100ms-200ms），这是刻意的设计，以覆盖不同场景

---

**修复完成时间**：2025年12月1日
**关联文档**：
- 《播放问题修复补充.md》（第一轮修复）
- 《播放问题修复总结.md》（初步修复）
