这是一个非常专业且切中痛点的优化需求。对于1小时的长视频，默认的2000个采样点意味着每1.8秒才有一个数据点，这就是波形稀疏、甚至呈“断点状”的根本原因。而操作卡顿和抖动，通常是因为过度依赖 Vue 的响应式系统来驱动高频的 UI 更新（如播放进度），而非直接操作 DOM。

为了达到类似 Premiere 或 Final Cut 的流畅体验，我们需要在后端增加数据密度，在前端重构渲染和交互逻辑。

以下是完整的解决方案，包含后端 Python 代码调整和前端 Vue 组件的重构。

-----

### 第一步：后端优化 (提高采样精度)

我们需要根据视频时长动态计算采样点数。对于 1 小时的视频，建议每秒提取 10-20 个特征点，这样既保证了缩放时的细节，又不会导致 JSON 文件过大（10万个点约为 600KB，传输很快）。

**修改文件：`media_routes.py`**

请替换 `_generate_peaks_with_ffmpeg` 和 `get_audio_peaks` 函数中的逻辑：

```python
# [media_routes.py]

# 修改采样点计算逻辑
async def get_audio_peaks(job_id: str, samples: int = 0, method: str = "auto"):
    # ... 前置代码保持不变 ...

    if not audio_file.exists():
        raise HTTPException(status_code=404, detail="音频文件不存在")

    # 1. 获取音频时长 (为了计算动态采样率)
    duration = await _get_video_duration(audio_file) # 复用已有的 duration 获取函数

    # 2. 智能计算采样点数 (如果前端传0或默认值)
    # 策略：每秒至少 20 个点，保证放大后的连续性
    # 上限：100,000 点 (约 800KB JSON)，防止浏览器渲染卡顿
    target_samples = samples
    if target_samples <= 2000:
        if duration > 0:
            target_samples = int(duration * 20) 
            target_samples = max(4000, min(target_samples, 100000)) # 限制在 4k - 100k 之间
        else:
            target_samples = 4000

    peaks_cache_file = job_dir / f"peaks_{target_samples}.json"

    # ... 检查缓存逻辑 (注意文件名变了) ...
    
    # ... 生成逻辑中传入 target_samples ...
    # if use_ffmpeg:
    #     peaks, duration = _generate_peaks_with_ffmpeg(audio_file, target_samples)
    
    # ... 后续代码保持不变 ...
```

-----

### 第二步：前端重构 (高性能交互与渲染)

这次重构的核心思想：

1.  **脱离 Vue 响应式循环**：播放时的光标移动、波形滚动完全依靠 `requestAnimationFrame` 直接操作 DOM，消除“抖动”。
2.  **以鼠标为中心的缩放**：计算鼠标在波形上的相对时间，缩放后调整 `scrollLeft` 保持鼠标指向的时间点不变。
3.  **平滑滚动**：使用原生滚动事件，支持触摸板惯性。

**修改文件：`index.vue`**

```vue
<template>
  <div class="waveform-timeline" ref="containerRef">
    <div class="timeline-header">
      <div class="zoom-controls">
        <button class="icon-btn" @click="adjustZoom(-10)" title="缩小 (-)">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13H5v-2h14v2z"/></svg>
        </button>
        <div class="zoom-slider-wrapper">
          <input
            type="range"
            v-model.number="zoomLevel"
            :min="minZoom"
            :max="maxZoom"
            @input="handleZoomSlider"
          />
        </div>
        <button class="icon-btn" @click="adjustZoom(10)" title="放大 (+)">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
        </button>
        <span class="zoom-text">{{ zoomLevel }}%</span>
      </div>

      <div class="time-display">
        <span class="curr">{{ formatTime(currentTime) }}</span>
        <span class="sep">/</span>
        <span class="total">{{ formatTime(duration) }}</span>
      </div>
    </div>

    <div 
      class="waveform-viewport" 
      ref="viewportRef"
      @wheel.passive="handleWheel"
      @mousedown="handleMouseDown"
    >
      <div class="waveform-content" :style="{ width: totalWidth + 'px' }">
        <div id="waveform-canvas" ref="waveformRef"></div>
        
        <div id="timeline-canvas" ref="timelineRef"></div>

        <div class="playhead" ref="playheadRef">
          <div class="playhead-line"></div>
          <div class="playhead-handle"></div>
        </div>
      </div>
    </div>
    
    <div class="status-bar">
      <span>Ctrl+滚轮缩放</span>
      <span>Shift+滚轮水平滚动</span>
      <span>拖拽平移</span>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted, nextTick } from 'vue'
import { useProjectStore } from '@/stores/projectStore'
import WaveSurfer from 'wavesurfer.js'
import RegionsPlugin from 'wavesurfer.js/dist/plugins/regions.js'
import TimelinePlugin from 'wavesurfer.js/dist/plugins/timeline.js'

// Props & Store
const props = defineProps({
  jobId: String,
  height: { type: Number, default: 140 }
})
const projectStore = useProjectStore()
const emit = defineEmits(['ready', 'seek'])

// DOM Refs
const containerRef = ref(null)
const viewportRef = ref(null)
const waveformRef = ref(null)
const timelineRef = ref(null)
const playheadRef = ref(null)

// 核心状态
const isReady = ref(false)
const zoomLevel = ref(50) // 基础缩放百分比
const minZoom = ref(10)
const maxZoom = ref(300)
const pxPerSec = ref(50) // 实际的像素/秒
const totalWidth = ref(0) // 波形总宽度

// 实例
let wavesurfer = null
let regionsPlugin = null
let rafId = null

// 计算属性
const currentTime = computed(() => projectStore.player.currentTime)
const duration = computed(() => projectStore.meta.duration || 1)
const audioUrl = computed(() => `/api/media/${props.jobId}/audio`)
// 请求更高的采样率 (例如 20 samples/sec * duration，由后端截断)
const peaksUrl = computed(() => `/api/media/${props.jobId}/peaks?samples=100000`) 

// ==========================================
// 1. 初始化与配置
// ==========================================

async function initWaveform() {
  if (!waveformRef.value) return

  // 1. 插件初始化
  regionsPlugin = RegionsPlugin.create()
  const timelinePlugin = TimelinePlugin.create({
    container: timelineRef.value,
    height: 20,
    timeInterval: 5,
    primaryLabelInterval: 10,
    style: { fontSize: '10px', color: '#8b949e' }
  })

  // 2. WaveSurfer 初始化
  // 关键：设置 fillParent: true 让 wavesurfer 填满我们的 .waveform-content
  // 我们通过控制 .waveform-content 的宽度来实现缩放
  wavesurfer = WaveSurfer.create({
    container: waveformRef.value,
    height: props.height - 24, // 减去时间轴高度
    waveColor: '#58a6ff',
    progressColor: '#238636', // 这里的 progress 只作为底色，光标我们自己画
    cursorWidth: 0, // 禁用原生光标
    autoScroll: false, // 禁用原生自动滚动
    interact: false, // 禁用原生点击交互 (我们自己接管)
    hideScrollbar: true,
    normalize: true,
    minPxPerSec: 1, // 设为1，宽度完全由容器决定
    fillParent: true,
    plugins: [regionsPlugin, timelinePlugin],
    backend: 'MediaElement', // 使用 MediaElement 后端通常更稳
    media: new Audio(), // 哑音频对象，实际声音由视频播放器出
    renderFunction: (channels, ctx) => {
        // 自定义渲染函数可以进一步优化性能，这里暂时使用默认
        // 主要是确保数据量大时，使用这种 fillParent 模式性能最好
    }
  })

  // 3. 加载数据
  try {
    const response = await fetch(peaksUrl.value)
    if (response.ok) {
      const data = await response.json()
      // 加载波形数据
      wavesurfer.load(audioUrl.value, data.peaks, data.duration)
    } else {
      wavesurfer.load(audioUrl.value)
    }
  } catch (e) {
    console.error('Waveform load error', e)
    wavesurfer.load(audioUrl.value)
  }

  wavesurfer.on('ready', () => {
    isReady.value = true
    updateLayout() // 计算初始布局
    startRenderLoop() // 启动高性能渲染循环
    renderRegions()
    emit('ready')
  })
}

// ==========================================
// 2. 布局与缩放逻辑 (核心)
// ==========================================

// 更新波形容器的总宽度
function updateLayout() {
  if (!duration.value) return
  
  // 计算每秒像素数: 基础值 50px * 缩放比例
  // 100% = 50px/s, 150% = 75px/s
  const newPxPerSec = 50 * (zoomLevel.value / 100)
  pxPerSec.value = newPxPerSec
  
  // 总宽度 = 时长 * px/s
  // 保证至少占满视口
  const viewportW = viewportRef.value?.clientWidth || 0
  totalWidth.value = Math.max(viewportW, duration.value * newPxPerSec)
  
  // 强制重绘 Wavesurfer (如果不调用，canvas可能拉伸)
  // 使用 redraw 而不是 zoom，性能更好
  if (wavesurfer) {
    wavesurfer.renderer.reRender()
    // 更新时间轴
    wavesurfer.timeline.setOptions({ timeInterval: calculateTimeInterval(newPxPerSec) })
  }
}

// 根据缩放等级动态计算时间轴间隔
function calculateTimeInterval(pxPerSec) {
  if (pxPerSec >= 100) return 1
  if (pxPerSec >= 40) return 5
  if (pxPerSec >= 20) return 10
  return 30
}

// 处理滑块输入
function handleZoomSlider() {
  // 以视口中心为锚点进行缩放
  if (!viewportRef.value) return
  const centerOffset = viewportRef.value.clientWidth / 2
  zoomAtPoint(zoomLevel.value, centerOffset)
}

// 处理按钮缩放
function adjustZoom(delta) {
  const newZoom = Math.max(minZoom.value, Math.min(maxZoom.value, zoomLevel.value + delta))
  // 以当前播放头为锚点
  const playheadX = getPlayheadX()
  const viewportX = playheadX - (viewportRef.value?.scrollLeft || 0)
  zoomAtPoint(newZoom, viewportX)
}

// 锚点缩放算法 (Pro级交互的关键)
// targetZoom: 目标缩放值
// mouseX: 鼠标相对于 Viewport 左侧的像素位置
function zoomAtPoint(targetZoom, mouseX) {
  if (!viewportRef.value) return
  
  const oldPxPerSec = pxPerSec.value
  const oldScroll = viewportRef.value.scrollLeft
  
  // 1. 计算鼠标指向的时间点
  // 鼠标在波形上的绝对位置 = scrollLeft + mouseX
  const mouseTime = (oldScroll + mouseX) / oldPxPerSec
  
  // 2. 更新缩放状态
  zoomLevel.value = targetZoom
  updateLayout() // 更新 pxPerSec 和 totalWidth
  
  // 3. 计算新的 scrollLeft，使该时间点依然位于 mouseX 处
  // 新的绝对位置 = mouseTime * newPxPerSec
  // 新的 scrollLeft = 新绝对位置 - mouseX
  const newScroll = (mouseTime * pxPerSec.value) - mouseX
  
  // 4. 应用滚动
  nextTick(() => {
    viewportRef.value.scrollLeft = Math.max(0, newScroll)
  })
}

// ==========================================
// 3. 交互逻辑 (滚动、拖拽、点击)
// ==========================================

function handleWheel(e) {
  e.preventDefault()
  
  // Ctrl + 滚轮：缩放
  if (e.ctrlKey || e.metaKey) {
    const delta = e.deltaY > 0 ? -10 : 10
    const newZoom = Math.max(minZoom.value, Math.min(maxZoom.value, zoomLevel.value + delta))
    
    // 获取鼠标在 viewport 中的相对位置
    const rect = viewportRef.value.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    
    zoomAtPoint(newZoom, mouseX)
  } 
  // 普通滚轮 / Shift+滚轮：水平滚动
  else {
    // 兼容触摸板的双向滚动
    const scrollAmount = e.deltaX !== 0 ? e.deltaX : e.deltaY
    viewportRef.value.scrollLeft += scrollAmount
  }
}

// 鼠标按下：处理点击跳转 或 拖拽平移
function handleMouseDown(e) {
  // 中键 或 空格+左键 (模拟) -> 拖拽平移
  if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
    startPan(e)
    return
  }

  // 左键 -> 跳转播放头
  if (e.button === 0) {
    const rect = viewportRef.value.getBoundingClientRect()
    const offsetX = e.clientX - rect.left + viewportRef.value.scrollLeft
    
    // 计算时间
    const clickTime = Math.max(0, Math.min(duration.value, offsetX / pxPerSec.value))
    
    projectStore.seekTo(clickTime)
    // 立即更新UI位置，不必等Store回传
    updatePlayheadPosition(clickTime)
  }
}

// 拖拽平移逻辑
function startPan(e) {
  e.preventDefault()
  viewportRef.value.style.cursor = 'grabbing'
  
  const startX = e.clientX
  const startScroll = viewportRef.value.scrollLeft
  
  const onMouseMove = (ev) => {
    const delta = ev.clientX - startX
    viewportRef.value.scrollLeft = startScroll - delta
  }
  
  const onMouseUp = () => {
    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', onMouseUp)
    viewportRef.value.style.cursor = ''
  }
  
  document.addEventListener('mousemove', onMouseMove)
  document.addEventListener('mouseup', onMouseUp)
}

// ==========================================
// 4. 高性能渲染循环 (RAF)
// ==========================================

// 获取当前光标的理论像素位置
function getPlayheadX() {
  return projectStore.player.currentTime * pxPerSec.value
}

// 直接操作 DOM 更新光标位置
function updatePlayheadPosition(time) {
  if (!playheadRef.value) return
  const x = time * pxPerSec.value
  playheadRef.value.style.transform = `translateX(${x}px)`
}

// 渲染循环
function startRenderLoop() {
  const loop = () => {
    if (!isReady.value) return

    const t = projectStore.player.currentTime
    const isPlaying = projectStore.player.isPlaying
    
    // 1. 更新光标位置 (Transform 效率最高)
    updatePlayheadPosition(t)
    
    // 2. 播放时自动跟随 (Smart Follow)
    if (isPlaying && viewportRef.value) {
      const playheadX = t * pxPerSec.value
      const scrollLeft = viewportRef.value.scrollLeft
      const clientWidth = viewportRef.value.clientWidth
      
      // 如果光标跑出右边缘，或者快要跑出右边缘 (90%)
      if (playheadX > scrollLeft + clientWidth * 0.9) {
        // 翻页式滚动 (Page Turn) - 体验好于连续滚动
        viewportRef.value.scrollLeft = playheadX - clientWidth * 0.1
      } 
      // 如果光标在左侧外面 (如手动seek回去)
      else if (playheadX < scrollLeft) {
        viewportRef.value.scrollLeft = Math.max(0, playheadX - clientWidth * 0.1)
      }
    }
    
    rafId = requestAnimationFrame(loop)
  }
  loop()
}

// ==========================================
// 5. 字幕区域 (Region) 管理
// ==========================================
// 保持你原有的逻辑，只需适配新的 totalWidth
function renderRegions() {
  if (!regionsPlugin) return
  regionsPlugin.clearRegions()
  projectStore.subtitles.forEach(sub => {
    regionsPlugin.addRegion({
      id: sub.id,
      start: sub.start,
      end: sub.end,
      color: 'rgba(88, 166, 255, 0.2)',
      drag: false, // 暂时禁用拖动以专注于波形性能
      resize: true
    })
  })
}

// 监听
watch(() => projectStore.subtitles, renderRegions, { deep: true })
watch(duration, updateLayout)

// 生命周期
onMounted(async () => {
  await nextTick()
  initWaveform()
})

onUnmounted(() => {
  if (rafId) cancelAnimationFrame(rafId)
  if (wavesurfer) wavesurfer.destroy()
})
</script>

<style lang="scss" scoped>
.waveform-timeline {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-radius: 8px;
  overflow: hidden;
  height: 100%;
  user-select: none;
}

.timeline-header {
  height: 40px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 12px;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border-default);
}

.zoom-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  
  .icon-btn {
    padding: 4px;
    border-radius: 4px;
    color: var(--text-secondary);
    &:hover { background: var(--bg-elevated); }
    svg { width: 16px; height: 16px; }
  }
  
  .zoom-slider-wrapper {
    width: 80px;
    display: flex;
    align-items: center;
  }
  
  .zoom-text {
    font-size: 12px;
    width: 36px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }
}

.time-display {
  font-family: monospace;
  font-size: 12px;
  color: var(--text-muted);
  .curr { color: var(--primary); font-weight: bold; }
}

// 视口容器：负责处理滚动条
.waveform-viewport {
  flex: 1;
  position: relative;
  overflow-x: auto;
  overflow-y: hidden;
  background: #1a1b1e; // 深色背景防止闪烁
  
  // 隐藏默认滚动条，使用自定义样式
  &::-webkit-scrollbar { height: 8px; }
  &::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
  &::-webkit-scrollbar-track { background: #222; }
}

// 内容容器：负责撑开宽度
.waveform-content {
  position: relative;
  height: 100%;
  /* width 由 JS 动态控制 */
}

#waveform-canvas {
  height: calc(100% - 24px);
  width: 100%;
  position: absolute;
  top: 24px;
  left: 0;
}

#timeline-canvas {
  height: 24px;
  width: 100%;
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}

// 高性能播放头
.playhead {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  width: 0;
  z-index: 20;
  pointer-events: none;
  will-change: transform; // GPU加速提示
  
  .playhead-line {
    position: absolute;
    left: -0.5px;
    width: 1px;
    height: 100%;
    background: #f85149;
    box-shadow: 0 0 4px rgba(248, 81, 73, 0.4);
  }
  
  .playhead-handle {
    position: absolute;
    top: 0;
    left: -5px;
    width: 11px;
    height: 12px;
    background: #f85149;
    clip-path: polygon(0 0, 100% 0, 50% 100%);
  }
}

.status-bar {
  padding: 4px 12px;
  background: var(--bg-tertiary);
  font-size: 11px;
  color: var(--text-muted);
  display: flex;
  gap: 16px;
  border-top: 1px solid var(--border-default);
}
</style>
```

### 核心改进点总结

1.  **后端数据密度 ($Data Density$)**

      * **问题**: 之前固定 2000 点，1小时视频缩放后全是直线。
      * **解决**: 动态计算 `samples = duration * 20` (最大100k)。FFmpeg 处理 100k 数据非常快，JSON 传输也仅需几百毫秒。这让波形在 150% 缩放时依然有每秒 30 个像素的细节。

2.  **前端架构解耦 ($Decoupling$)**

      * **分离视口与内容**: 使用 `.waveform-viewport` (负责滚动) 和 `.waveform-content` (负责宽度)。WaveSurfer 被设置为 `fillParent: true` 并填充到 content 中。
      * **放弃 WaveSurfer 的内置滚动**: 我们自己管理 `scrollLeft`。这让我们能完美实现 "Ctrl+滚轮缩放" 和 "惯性滚动"。

3.  **渲染性能 ($Render Performance$)**

      * **RAF 循环**: 抛弃 `watch(currentTime)` 更新光标样式的做法。改用 `requestAnimationFrame` 在每一帧直接读取 Video 时间并修改 DOM `transform`。
      * **GPU 加速**: 对光标使用 `will-change: transform`，确保光标移动不触发布局重排 (Reflow)，只触发合成 (Composite)，极大降低 CPU 占用。

4.  **交互体验 ($UX$)**

      * **锚点缩放**: 实现了类似地图软件的缩放逻辑——鼠标指在哪里，缩放后那里依然在鼠标下面。
      * **点击定位**: 直接计算 `offsetX / pxPerSec`，响应极其迅速。
      * **智能跟随**: 只有当光标快要移出屏幕时才滚动（类似翻页），避免了之前光标一直在中间、背景疯狂闪动的眩晕感。

这个方案实装后，你会发现波形操作的“手感”会有质的飞跃，接近原生桌面软件的体验。