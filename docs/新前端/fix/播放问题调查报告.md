# 播放问题深度调查报告

## 1. Space键控制问题

### 1.1 事实发现

#### 快捷键系统架构
- `useShortcuts.js` (第66-71行): 全局Space键监听，当按下时调用 `actions.togglePlay?.()`
- `EditorView.vue` (第919-942行): 正确配置了useShortcuts，包含togglePlay函数
- `EditorView.vue` (第46-50行): **VideoStage组件被明确设置了 `:enable-keyboard="false"`**

#### 双重键盘监听系统
系统存在**两套键盘监听机制**:
1. **全局useShortcuts** (在EditorView层激活): 监听所有快捷键，包括Space
2. **VideoStage内置键盘** (被禁用): VideoStage/index.vue第470-494行的handleKeyboard函数

#### useShortcuts的焦点检测逻辑
`useShortcuts.js` (第22-28行) 的焦点检测逻辑:
```javascript
const isInputActive = target.tagName === 'INPUT' ||
                      target.tagName === 'TEXTAREA' ||
                      target.isContentEditable

// 第二类：输入框保护 (输入文字时不触发)
if (isInputActive) return

// 播放/暂停 (Space)
if (code === 'Space') {
  e.preventDefault()
  actions.togglePlay?.()
  return
}
```

#### 问题场景重现
用户在波形区域点击后，Space键失效的可能原因:
1. 波形组件获取焦点，但焦点检测只针对INPUT/TEXTAREA，波形区域不会触发拦截
2. **关键发现**: EditorView正确使用了useShortcuts，全局Space键应该有效

### 1.2 问题确认
**问题不在于焦点检测逻辑**。useShortcuts的焦点检测逻辑合理，波形组件不会影响Space键。

**真正的问题可能是**:
1. EditorView的useShortcuts配置可能有问题
2. togglePlay函数实现可能有bug
3. 可能存在事件冒泡/捕获冲突

### 1.3 修复建议
1. 检查togglePlay函数实现 (EditorView.vue第836-838行)
2. 添加debug日志确认Space键是否被捕获
3. 检查是否存在多个事件监听器冲突

## 2. 进度条拖动问题

### 2.1 事实发现

#### 数据流架构
```
projectStore.player.currentTime  (全局状态中心)
       ↑              ↓
       │              │
    VideoStage    WaveformTimeline
    (主播放器)      (波形显示)
       ↑              ↓
       │              │
       ↓              ↑
  PlaybackControls (进度条UI)
```

#### 循环同步的关键代码位置

**VideoStage时间更新** (第363-368行):
```javascript
function onTimeUpdate() {
  const video = videoRef.value
  // 使用防抖更新 Store 时间（减少高频更新）
  debouncedTimeUpdate(video.currentTime)  // 200ms 防抖
  emit('timeupdate', video.currentTime)
}
```

**防抖实现** (第139-142行):
```javascript
function debouncedTimeUpdate(time) {
  if (timeUpdateTimer) clearTimeout(timeUpdateTimer)
  timeUpdateTimer = setTimeout(() => {
    // 只有当时间差较大时才更新（避免循环触发）
    // 实际更新逻辑...
  }, 200)  // 200ms 防抖
}
```

**VideoStage响应Store变化** (第251-265行):
```javascript
watch(() => projectStore.player.currentTime, (newTime) => {
  if (!videoRef.value) return
  const now = Date.now()

  // 防止循环同步：如果刚刚由video更新了Store，则跳过
  if (now - lastSyncTime.value < 300) return  // 300ms 防循环

  // 只有当时间差较大时才seek（避免小抖动）
  const timeDiff = Math.abs(videoRef.value.currentTime - newTime)
  if (timeDiff > 0.5) {
    videoRef.value.currentTime = newTime
    lastSyncTime.value = now
  }
})
```

**PlaybackControls拖动实现** (第180-198行):
```javascript
function startDrag(e) {
  isDragging.value = true
  document.addEventListener('mousemove', onDrag)
  document.addEventListener('mouseup', stopDrag)
}

function onDrag(e) {
  if (!isDragging.value || !progressRef.value || !duration.value) return
  const rect = progressRef.value.getBoundingClientRect()
  const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width))
  const newTime = percent * duration.value
  projectStore.seekTo(newTime)  // 直接调用store的seekTo
}

function stopDrag() {
  isDragging.value = false
  document.removeEventListener('mousemove', onDrag)
  document.removeEventListener('mouseup', stopDrag)
}
```

**WaveformTimeline的seek逻辑** (第698-744行):
```javascript
function handleUpperZoneMouseDown(e) {
  // ...
  const clickTime = getTimeFromClientX(e.clientX)
  isUserSeeking.value = true
  projectStore.seekTo(clickTime)  // 同样调用store的seekTo
  // ...
  setTimeout(() => {
    isUserSeeking.value = false
  }, 200)  // 200ms 后解除标记
}
```

**Store的seekTo实现** (projectStore.js第316-318行):
```javascript
function seekTo(time) {
  player.value.currentTime = time;  // 直接赋值，触发所有watch监听器
}
```

**WaveformTimeline的响应逻辑** (第964-975行):
```javascript
// 播放时不要同步（避免闪现），让 WaveSurfer 自己播放
if (projectStore.player.isPlaying && !isUserSeeking.value) {
  return;
}

// 节流：避免过于频繁的同步（最少间隔100ms）
const now = Date.now();
if (now - lastSyncTime < 100) {
  return;
}
lastSyncTime = now;
```

### 2.2 循环触发分析

#### 问题1: 时间窗口冲突
- `debouncedTimeUpdate`: 200ms 防抖
- `lastSyncTime`: 300ms 防循环 (VideoStage)
- `WaveformTimeline lastSyncTime`: 100ms 节流
- `isUserSeeking`: 200ms 保护窗口 (仅WaveformTimeline使用)

#### 问题2: 时序冲突场景
当用户拖动PlaybackControls进度条时:
1. `onDrag(e)` → `projectStore.seekTo(newTime)` (立即)
2. 触发 `VideoStage watch` → `video.currentTime = newTime` (立即，但seek可能需要时间)
3. 触发 `WaveformTimeline watch` → `wavesurfer.seekTo()` (立即)
4. **video元素seek完成后** → 触发 `timeupdate` 事件
5. `onTimeUpdate` → `debouncedTimeUpdate(video.currentTime)` (200ms后)
6. 如果此时video.seek还没完成，可能会把时间"拉回"

#### 问题3: 缺乏统一的Seek锁
- 只有 `WaveformTimeline` 使用了 `isUserSeeking` 标记
- `PlaybackControls` 和 `EditorView` 的seek操作都没有保护锁
- `VideoStage` 的防循环逻辑基于时间戳，不够精确

### 2.3 修复建议
1. **引入全局Seek锁**: 在projectStore中添加 `isUserSeeking` 状态
2. **所有seek操作都要设置锁**: PlaybackControls、WaveformTimeline、EditorView
3. **使用seeking/seeked事件**: 替代依赖timeupdate来检测seek完成
4. **统一防抖时间**: 确保所有组件的时间窗口一致

## 3. 事件处理机制调查

### 3.1 事实发现
- **VideoStage未监听seeking/seeked事件**: 只依赖timeupdate事件
- **只有一个全局时间状态**: projectStore.player.currentTime
- **多个组件修改同一状态**: PlaybackControls、WaveformTimeline、VideoStage、EditorView
- **缺乏统一的事件协调机制**: 各组件独立响应，容易产生竞态条件

### 3.2 事件传播路径
```
用户拖动进度条
    ↓
PlaybackControls.onDrag
    ↓
projectStore.seekTo(newTime)
    ↓
触发多个watch监听器
    ├── VideoStage: video.currentTime = newTime
    ├── WaveformTimeline: wavesurfer.seekTo()
    └── PlaybackControls: 更新UI (computed)
    ↓
video元素开始seek
    ↓
seek完成后触发timeupdate
    ↓
VideoStage.onTimeUpdate
    ↓
debouncedTimeUpdate → projectStore.player.currentTime
    ↓
再次触发watch监听器 (潜在循环)
```

## 4. 总结

### 4.1 优先级排序
1. **高优先级**: 进度条拖动循环问题 - 严重影响用户体验
2. **中优先级**: Space键控制问题 - 需要进一步调试确认
3. **低优先级**: 事件处理机制优化 - 长期架构改进

### 4.2 风险评估
- **进度条问题**: 风险高，但修复相对简单，主要是引入全局锁机制
- **Space键问题**: 风险中等，可能需要深入调试事件处理
- **架构改进**: 风险低，但需要谨慎重构

### 4.3 测试建议
1. **进度条拖动测试**: 拖动到不同位置，观察是否跳回原点
2. **键盘控制测试**: 在不同区域点击后测试Space键响应
3. **竞态条件测试**: 快速连续拖动进度条，观察是否有延迟或冲突
4. **边界情况测试**: 在视频开始/结束位置拖动，在播放状态下拖动