# 模型下载与 SSE 连接修复方案开发文档 (小型项目简化版)

## 1\. 问题背景与现状分析

当前项目在模型下载、预加载及前后端交互中存在严重性能瓶颈与逻辑缺陷，主要表现为：

  * **现象**：前端频繁连接超时、全局接口卡顿、模型重复下载、SSE 连接数暴涨。
  * **根因**：
    1.  **事件循环阻塞**：后端 SSE 使用阻塞式 `queue.Queue.get`，导致 `FastAPI` 的异步主线程被卡死。
    2.  **竞态条件**：模型下载检查逻辑缺乏原子性（检查与执行未加锁），导致并发请求触发重复下载。
    3.  **状态非持久化**：前端下载状态绑定在“弹窗组件”内，关闭弹窗即丢失进度上下文。
    4.  **接口缺失**：预加载功能缺乏对应的后端 API，导致前端 404 错误。

-----

## 2\. 核心修复方案 (后端)

### 2.1 SSE 通信重构 (优先级 P0)

**目标**：彻底解除对 `uvicorn` 主事件循环的阻塞，实现非阻塞的消息推送。

  * **数据结构变更**：
      * 弃用 `queue.Queue` (线程阻塞)，改用 `asyncio.Queue` (协程友好)。
      * SSE 生成器内部使用 `await queue.get()`，配合 `asyncio.wait_for` 实现心跳。
  * **跨线程通信桥接**：
      * 下载任务运行在独立线程 (`threading.Thread`) 中。
      * 线程向 SSE 推送消息时，必须使用 `loop.call_soon_threadsafe(queue.put_nowait, data)` 将消息注入到主事件循环。
  * **简化版连接管理**：
      * 不搞复杂的背压机制。为每个连接维护一个 `asyncio.Queue`，连接断开时直接从全局列表移除该 Queue。

### 2.2 下载并发控制 (优先级 P0)

**目标**：确保同一模型不重复下载，且限制全局并发度以保护带宽。

  * **全局下载锁**：
      * 引入全局锁 `threading.Lock` 用于保护“下载状态检查”和“任务启动”的关键临界区。
      * **双重检查锁定 (Double-Checked Locking)**：
        ```python
        # 伪代码示例
        if is_downloading(model_id): return  # 第一次检查（快速失败）
        with global_download_lock:
            if is_downloading(model_id): return  # 锁内第二次检查（确保原子性）
            start_download_thread()
        ```
  * **串行/简单的并发限制**：
      * 对于小型项目，无需引入任务调度器。使用一个简单的 `Semaphore(1)` 或直接在锁内逻辑控制，确保同一时间只有一个重型下载任务（Whisper 或 Align）在运行，或者 Whisper 与 Align 各允许一个并发。

### 2.3 捆绑下载对齐模型 (业务逻辑增强)

**目标**：下载 Whisper 模型时，自动处理官方推荐的对齐模型 (Alignment Model)。

  * **逻辑流程**：
    1.  用户触发 Whisper 下载。
    2.  后端检查该 Whisper 模型对应的推荐对齐模型（如 `wav2vec2-large-xlsr-53-chinese`）。
    3.  若对齐模型**不存在**或**不完整**，则将其加入下载队列。
    4.  **执行策略**：建议采用**串行策略**（下载完 Whisper 后自动开始下载 Align），以降低带宽压力和代码复杂度。

### 2.4 预加载 API 补齐

**目标**：消除前端 404 错误，统一预加载逻辑。

  * **新增路由**：
      * `POST /api/preload/start`: 触发预加载（幂等设计，若已加载则立即返回）。
      * `GET /api/preload/status`: 返回预加载进度、缓存状态。
      * `POST /api/preload/clear-cache`: 手动清理显存。
  * **并发协同**：预加载触发的模型加载也必须经过上述的“全局下载锁”，避免与用户手动下载冲突。

-----

## 3\. 核心修复方案 (前端)

### 3.1 SSE 全局单例化

**目标**：解决“关闭窗口无法更新进度”及“多窗口多连接”问题。

  * **架构调整**：
      * 将 `EventSource` 的创建与监听移至 `App.vue` 或全局 Store (Pinia/Vuex) 中。
      * **生命周期**：应用启动时建立连接，应用关闭时断开。
      * **状态分发**：全局监听 SSE 事件，收到 `model_progress` 事件时，更新全局 Store 中的模型状态列表。
  * **模型管理弹窗逻辑**：
      * 弹窗组件**不再**负责建立 SSE 连接。
      * 弹窗打开时 (`onOpen`)：调用 `GET /models` 获取当前最新快照。
      * 弹窗渲染时：直接读取全局 Store 中的数据（该数据由后台 SSE 持续更新）。
      * **结果**：关闭弹窗，SSE 依然在后台接收进度；再次打开弹窗，通过 Store 数据看到的是最新进度。

### 3.2 下载交互优化

  * **三段式状态同步**：
    1.  **点击瞬间**：前端立即将按钮置灰，状态设为 `waiting` (乐观更新)。
    2.  **SSE 推送**：收到后端 `downloading` 事件，更新进度条。
    3.  **最终状态**：收到 `complete` 或 `error`，恢复按钮状态。
  * **防抖与禁重**：
      * 下载按钮点击后，在收到明确的后端失败响应前，禁止再次点击。

-----

## 4\. 实施细节与伪代码

### 4.1 后端：非阻塞 SSE 实现

```python
import asyncio
from fastapi import Request
from sse_starlette.sse import EventSourceResponse

# 全局连接池，存储每个客户端的 asyncio.Queue
client_queues = []

async def stream_events(request: Request):
    queue = asyncio.Queue()
    client_queues.append(queue)
    try:
        while True:
            # 检查客户端是否断开
            if await request.is_disconnected():
                break
            # 非阻塞等待消息，设置超时用于发送心跳
            try:
                data = await asyncio.wait_for(queue.get(), timeout=15)
                yield {"data": data}
            except asyncio.TimeoutError:
                yield {"event": "ping", "data": "heartbeat"}
    finally:
        client_queues.remove(queue)

# 供下载线程调用的工具函数
def notify_clients(message):
    # 获取当前运行的 loop (通常在启动时保存全局 loop 引用)
    loop = get_running_loop_safely() 
    for q in client_queues:
        loop.call_soon_threadsafe(q.put_nowait, message)
```

### 4.2 后端：带锁的下载逻辑 (含对齐模型捆绑)

```python
import threading

download_lock = threading.Lock()
is_downloading_dict = {} # {model_id: bool}

def download_whisper_task(model_id, need_align=True):
    # 1. 下载 Whisper
    try:
        notify_clients({"event": "progress", "model": model_id, "percent": 0})
        # ...执行实际下载逻辑...
        notify_clients({"event": "complete", "model": model_id})
    except Exception as e:
        notify_clients({"event": "error", "model": model_id})
        return

    # 2. 自动下载对齐模型 (串行执行，简单可靠)
    if need_align:
        align_model_id = get_align_model_for(model_id)
        if not check_model_exists(align_model_id):
             download_align_task(align_model_id)

def start_download(model_id):
    # 双重检查锁定
    if is_downloading_dict.get(model_id):
        return {"status": "already_downloading"}
    
    with download_lock:
        if is_downloading_dict.get(model_id):
            return {"status": "already_downloading"}
        
        is_downloading_dict[model_id] = True
        # 启动线程
        thread = threading.Thread(target=download_whisper_task, args=(model_id,))
        thread.start()
        return {"status": "started"}
```

-----

## 5\. 部署与配置建议 (无需改代码部分)

1.  **开发环境 (Vite)**:
      * 无需特殊配置，Vite 默认支持 SSE 透传。
2.  **生产环境 / 局域网部署 (若有 Nginx)**:
      * 必须关闭 SSE 路径的缓冲，否则前端会隔很久才收到一堆数据。
    <!-- end list -->
    ```nginx
    location /api/events {
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 3600s;
        proxy_http_version 1.1;
        chunked_transfer_encoding off;
    }
    ```

-----

## 6\. 验收标准 Checklist

  * [ ] **性能**：点击下载时，其他 API 接口（如页面刷新）不再转圈卡顿。
  * [ ] **连接**：打开多个浏览器标签页，后端日志显示的 SSE 连接数正确（每个标签页 1 个，或全应用单例）。
  * [ ] **持久化**：点击下载 -\> 关闭模型窗口 -\> 等待几秒 -\> 重新打开窗口 -\> 进度条显示当前进度（而非 0% 或空）。
  * [ ] **并发**：快速连续点击同一个模型的“下载”按钮，后端日志显示只启动了一个下载线程。
  * [ ] **完整性**：下载中文 Whisper 模型后，检查磁盘目录，确认对应的 Align 模型也已自动下载。
  * [ ] **预加载**：前端调用 `preload/status` 不再报 404 错误。