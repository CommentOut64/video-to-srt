# Demucs äººå£°åˆ†ç¦»é›†æˆæ–¹æ¡ˆ

## ğŸ“‹ èƒŒæ™¯ä¸ç›®æ ‡

### é—®é¢˜åœºæ™¯
åœ¨æœ‰èƒŒæ™¯éŸ³ä¹çš„è§†é¢‘ä¸­ï¼š
- Silero VAD å¯èƒ½è¢«èƒŒæ™¯éŸ³ä¹å¹²æ‰°ï¼Œé”™è¯¯åœ°å°†éŸ³ä¹æ®µè¯†åˆ«ä¸ºè¯­éŸ³æ®µ
- Whisper åœ¨èƒŒæ™¯éŸ³ä¹å¼ºçš„æ®µè½å¯èƒ½è½¬å½•å¤±è´¥æˆ–ç½®ä¿¡åº¦å¾ˆä½
- å­—å¹•æ—¶é—´æˆ³æå‰/å»¶åï¼Œå› ä¸º VAD è¾¹ç•Œä¸å‡†ç¡®

### è§£å†³æ–¹æ¡ˆ
é›†æˆ **Demucs (Hybrid Transformer Demucs)** è¿›è¡Œäººå£°åˆ†ç¦»ï¼š
- æ¨¡å‹å°å·§ï¼šä»… 40-80MB
- äººå£°ä¿çœŸåº¦é«˜ï¼Œä¸ä¼šäº§ç”Ÿ"æ°´ä¸‹éŸ³"å¤±çœŸ
- æ”¯æŒ GPU åŠ é€Ÿï¼Œé€Ÿåº¦å¿«

### ç­–ç•¥é€‰æ‹©

æˆ‘ä»¬é‡‡ç”¨**"æ™ºèƒ½æ£€æµ‹ + åŠ¨æ€ç†”æ–­"**çš„æ··åˆç­–ç•¥ï¼š

| ç­–ç•¥ | è¯´æ˜ | é€‚ç”¨åœºæ™¯ |
|------|------|----------|
| **å…¨å±€é¢„å¤„ç†** | æ•´ä¸ªéŸ³é¢‘å…ˆåˆ†ç¦»äººå£°ï¼Œå†è¿›è¡Œåç»­å¤„ç† | çº¯éŸ³ä¹ç±»è§†é¢‘ã€MV |
| **æŒ‰éœ€åˆ†ç¦»** | åªå¯¹ä½ç½®ä¿¡åº¦æ®µè½è¿›è¡Œåˆ†ç¦»é‡è¯• | æ™®é€šå¯¹è¯è§†é¢‘ï¼ˆå¶å°”æœ‰BGMï¼‰ |
| **æ™ºèƒ½æ¨¡å¼** | å…ˆæ£€æµ‹èƒŒæ™¯éŸ³ä¹å¼ºåº¦ï¼Œè‡ªåŠ¨é€‰æ‹©ç­–ç•¥ | é»˜è®¤æ¨è |
| **åŠ¨æ€ç†”æ–­** | è½¬å½•è¿‡ç¨‹ä¸­æ£€æµ‹åˆ°æŒç»­ä½ç½®ä¿¡åº¦ï¼Œè‡ªåŠ¨å‡çº§ä¸ºå…¨å±€æ¨¡å¼ | è‡ªåŠ¨å…œåº• |

### æ ¸å¿ƒåˆ›æ–°ï¼šåŠ¨æ€ç†”æ–­æœºåˆ¶

å³ä½¿åˆå§‹æ£€æµ‹åˆ¤å®šä¸º"æ— BGM"ï¼Œåœ¨è½¬å½•è¿‡ç¨‹ä¸­å¦‚æœå‘ç°ï¼š
- è¿ç»­ 3 ä¸ª segment è§¦å‘ä½ç½®ä¿¡åº¦é‡è¯•
- æˆ–æ€» segment çš„ 20% éƒ½éœ€è¦å±€éƒ¨ Demucs é‡è¯•

ç³»ç»Ÿä¼š**è‡ªåŠ¨ç†”æ–­**ï¼Œåœæ­¢å½“å‰æµç¨‹ï¼Œå¼ºåˆ¶å‡çº§ä¸º**å…¨å±€åˆ†ç¦»æ¨¡å¼**é‡æ–°å¤„ç†ã€‚

è¿™è§£å†³äº†"é‡‡æ ·æ¼ç½‘"é—®é¢˜â€”â€”æŸäº›è§†é¢‘å‰ä¸­åæ®µéƒ½å¾ˆå¹²å‡€ï¼Œä½†ä¸­é—´æŸå¤„çªç„¶å‡ºç°æ¿€çƒˆBGMã€‚

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æµç¨‹ï¼ˆæ–°ç‰ˆï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         è½¬å½•ä¸»æµç¨‹ (TranscriptionService)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. éŸ³é¢‘æå–                                                             â”‚
â”‚     â””â”€ ffmpegæå–WAV                                                    â”‚
â”‚                                                                         â”‚
â”‚  2. ã€æ–°å¢ã€‘èƒŒæ™¯éŸ³ä¹æ£€æµ‹ï¼ˆå¯é€‰ï¼‰                                           â”‚
â”‚     â””â”€ DemucsService.detect_background_music_level()                    â”‚
â”‚        â”œâ”€ åˆ†ä½æ•°é‡‡æ ·ï¼ˆ15%ã€50%ã€85%å¤„å„å–10ç§’ï¼‰                            â”‚
â”‚        â”œâ”€ è®¡ç®— BGM èƒ½é‡å æ¯”                                               â”‚
â”‚        â””â”€ è¿”å›: "none" | "light" | "heavy"                              â”‚
â”‚                                                                         â”‚
â”‚  3. ã€æ–°å¢ã€‘å…¨å±€äººå£°åˆ†ç¦»ï¼ˆheavyæ¨¡å¼ä¸‹ï¼‰                                     â”‚
â”‚     â””â”€ DemucsService.separate_vocals()                                  â”‚
â”‚        â””â”€ è¿”å›: vocals.wavï¼ˆçº¯äººå£°ï¼‰                                      â”‚
â”‚                                                                         â”‚
â”‚  4. VADåˆ†æ®µ                                                              â”‚
â”‚     â””â”€ ä½¿ç”¨åŸå§‹/åˆ†ç¦»åçš„éŸ³é¢‘è¿›è¡ŒVAD                                        â”‚
â”‚                                                                         â”‚
â”‚  5. è½¬å½•å¤„ç†ï¼ˆå¸¦åŠ¨æ€ç†”æ–­æœºåˆ¶ï¼‰                                              â”‚
â”‚     â””â”€ _transcribe_segment_with_retry()                                 â”‚
â”‚        â”œâ”€ é¦–æ¬¡è½¬å½•ï¼ˆä½¿ç”¨åŸå§‹éŸ³é¢‘ï¼‰                                         â”‚
â”‚        â”œâ”€ ã€æ–°å¢ã€‘ç½®ä¿¡åº¦æ£€æµ‹                                              â”‚
â”‚        â”‚   â””â”€ avg_logprob < -0.8 æˆ– no_speech_prob > 0.6                â”‚
â”‚        â”œâ”€ ã€æ–°å¢ã€‘æŒ‰éœ€åˆ†ç¦»é‡è¯•ï¼ˆlight/noneæ¨¡å¼ä¸‹ï¼‰                          â”‚
â”‚        â”‚   â””â”€ DemucsService.separate_vocals_segment()                   â”‚
â”‚        â”œâ”€ ã€æ–°å¢ã€‘ç†”æ–­è®¡æ•°å™¨                                              â”‚
â”‚        â”‚   â””â”€ è¿ç»­3æ®µæˆ–æ€»20%è§¦å‘é‡è¯• â†’ å‡çº§ä¸ºå…¨å±€æ¨¡å¼                       â”‚
â”‚        â””â”€ è¿”å›æœ€ä½³ç»“æœ æˆ– æŠ›å‡º BreakToGlobalSeparation å¼‚å¸¸               â”‚
â”‚                                                                         â”‚
â”‚  5.5ã€æ–°å¢ã€‘ç†”æ–­å¤„ç†                                                      â”‚
â”‚     â””â”€ æ•è· BreakToGlobalSeparation                                     â”‚
â”‚        â”œâ”€ ä¸¢å¼ƒå·²è½¬å½•å†…å®¹                                                  â”‚
â”‚        â”œâ”€ å…¨å±€äººå£°åˆ†ç¦»                                                    â”‚
â”‚        â””â”€ ä» Step 4 é‡æ–°å¼€å§‹                                             â”‚
â”‚                                                                         â”‚
â”‚  6. å¯¹é½ & ç”ŸæˆSRT                                                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ–°å¢æœåŠ¡ï¼šDemucsService

```
backend/app/services/
â”œâ”€â”€ transcription_service.py  (ç°æœ‰ï¼Œéœ€ä¿®æ”¹)
â”œâ”€â”€ demucs_service.py         (æ–°å¢)
â””â”€â”€ ...
```

---

## ğŸ’» ä»£ç å®ç°

### 1. DemucsService å®Œæ•´å®ç°

```python
# backend/app/services/demucs_service.py

"""
Demucs äººå£°åˆ†ç¦»æœåŠ¡
ä½¿ç”¨ Hybrid Transformer Demucs (htdemucs) æ¨¡å‹è¿›è¡Œé«˜è´¨é‡äººå£°æå–
"""

import os
import gc
import logging
import tempfile
import hashlib
from pathlib import Path
from typing import Optional, Tuple, Literal
from enum import Enum
from dataclasses import dataclass

import torch
import numpy as np
import soundfile as sf


class BGMLevel(Enum):
    """èƒŒæ™¯éŸ³ä¹å¼ºåº¦çº§åˆ«"""
    NONE = "none"      # æ— èƒŒæ™¯éŸ³ä¹
    LIGHT = "light"    # è½»å¾®èƒŒæ™¯éŸ³ä¹ï¼ˆæŒ‰éœ€åˆ†ç¦»ï¼‰
    HEAVY = "heavy"    # å¼ºèƒŒæ™¯éŸ³ä¹ï¼ˆå…¨å±€åˆ†ç¦»ï¼‰


@dataclass
class DemucsConfig:
    """Demucsé…ç½®"""
    model_name: str = "htdemucs"          # æ¨¡å‹åç§°
    device: str = "cuda"                   # è®¾å¤‡ (cuda/cpu)
    shifts: int = 1                        # å¢å¼ºæ¬¡æ•°ï¼ˆ1=å¿«é€Ÿï¼Œ5=é«˜è´¨é‡ï¼‰
    overlap: float = 0.25                  # åˆ†æ®µé‡å ç‡
    segment_length: int = 10               # æ¯æ®µå¤„ç†é•¿åº¦ï¼ˆç§’ï¼‰
    
    # æŒ‰éœ€åˆ†ç¦»çš„ç¼“å†²åŒº
    segment_buffer_sec: float = 2.0        # åˆ†ç¦»æ—¶å‰åå„åŠ çš„ç¼“å†²ï¼ˆç§’ï¼‰
    
    # BGMæ£€æµ‹å‚æ•°ï¼ˆåˆ†ä½æ•°é‡‡æ ·ç­–ç•¥ï¼‰
    bgm_sample_duration: float = 10.0      # æ¯ä¸ªé‡‡æ ·ç‰‡æ®µçš„é•¿åº¦ï¼ˆç§’ï¼‰
    bgm_light_threshold: float = 0.2       # è½»å¾®BGMé˜ˆå€¼ï¼ˆBGMèƒ½é‡å æ¯”ï¼‰
    bgm_heavy_threshold: float = 0.6       # å¼ºBGMé˜ˆå€¼ï¼ˆåªè¦æœ‰ä¸€å¤„è¶…è¿‡æ­¤å€¼å³ä¸ºHeavyï¼‰


class DemucsService:
    """
    Demucsäººå£°åˆ†ç¦»æœåŠ¡
    
    æ”¯æŒä¸‰ç§ä½¿ç”¨æ¨¡å¼ï¼š
    1. å…¨å±€åˆ†ç¦»ï¼šå¤„ç†æ•´ä¸ªéŸ³é¢‘æ–‡ä»¶ï¼Œè¿”å›çº¯äººå£°
    2. æŒ‰éœ€åˆ†ç¦»ï¼šåªå¤„ç†æŒ‡å®šçš„æ—¶é—´æ®µ
    3. BGMæ£€æµ‹ï¼šå¿«é€Ÿæ£€æµ‹èƒŒæ™¯éŸ³ä¹å¼ºåº¦
    """
    
    _instance = None
    _model = None
    _model_lock = None
    
    def __new__(cls):
        if cls._instance is None:
            import threading
            cls._instance = super().__new__(cls)
            cls._model_lock = threading.Lock()
        return cls._instance
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.config = DemucsConfig()
        self._cache_dir = Path("models/demucs")
        self._cache_dir.mkdir(parents=True, exist_ok=True)
    
    def _load_model(self, device: str = None):
        """
        æ‡’åŠ è½½Demucsæ¨¡å‹
        
        æ¨¡å‹é¦–æ¬¡åŠ è½½æ—¶ä¼šè‡ªåŠ¨ä¸‹è½½ï¼ˆ~80MBï¼‰
        """
        if device:
            self.config.device = device
            
        with self._model_lock:
            if self._model is not None:
                return self._model
            
            self.logger.info(f"åŠ è½½Demucsæ¨¡å‹: {self.config.model_name}")
            
            try:
                from demucs.pretrained import get_model
                from demucs.apply import apply_model
                
                # åŠ è½½é¢„è®­ç»ƒæ¨¡å‹
                self._model = get_model(self.config.model_name)
                
                # ç§»åŠ¨åˆ°æŒ‡å®šè®¾å¤‡
                if self.config.device == "cuda" and torch.cuda.is_available():
                    self._model.cuda()
                    self.logger.info("Demucsæ¨¡å‹å·²åŠ è½½åˆ°GPU")
                else:
                    self._model.cpu()
                    self.config.device = "cpu"
                    self.logger.info("Demucsæ¨¡å‹å·²åŠ è½½åˆ°CPU")
                
                self._model.eval()
                return self._model
                
            except ImportError:
                raise RuntimeError(
                    "Demucsæœªå®‰è£…ï¼Œè¯·è¿è¡Œ: pip install demucs"
                )
    
    def unload_model(self):
        """å¸è½½æ¨¡å‹é‡Šæ”¾æ˜¾å­˜"""
        with self._model_lock:
            if self._model is not None:
                del self._model
                self._model = None
                gc.collect()
                if torch.cuda.is_available():
                    torch.cuda.empty_cache()
                self.logger.info("Demucsæ¨¡å‹å·²å¸è½½")
    
    def separate_vocals(
        self,
        audio_path: str,
        output_path: Optional[str] = None,
        progress_callback: Optional[callable] = None
    ) -> str:
        """
        å…¨å±€äººå£°åˆ†ç¦»ï¼ˆå¤„ç†æ•´ä¸ªéŸ³é¢‘æ–‡ä»¶ï¼‰
        
        Args:
            audio_path: è¾“å…¥éŸ³é¢‘è·¯å¾„
            output_path: è¾“å‡ºè·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤åœ¨åŒç›®å½•ç”Ÿæˆ xxx_vocals.wavï¼‰
            progress_callback: è¿›åº¦å›è°ƒ callback(progress: float, message: str)
        
        Returns:
            str: åˆ†ç¦»åçš„äººå£°æ–‡ä»¶è·¯å¾„
        """
        from demucs.apply import apply_model
        from demucs.audio import AudioFile, save_audio
        
        self.logger.info(f"å¼€å§‹å…¨å±€äººå£°åˆ†ç¦»: {audio_path}")
        
        # ç”Ÿæˆè¾“å‡ºè·¯å¾„
        if output_path is None:
            audio_dir = Path(audio_path).parent
            audio_stem = Path(audio_path).stem
            output_path = str(audio_dir / f"{audio_stem}_vocals.wav")
        
        # æ£€æŸ¥ç¼“å­˜
        cache_key = self._get_cache_key(audio_path, "full")
        cached_path = self._cache_dir / f"{cache_key}_vocals.wav"
        if cached_path.exists():
            self.logger.info(f"ä½¿ç”¨ç¼“å­˜çš„åˆ†ç¦»ç»“æœ: {cached_path}")
            return str(cached_path)
        
        model = self._load_model()
        
        if progress_callback:
            progress_callback(0.1, "åŠ è½½éŸ³é¢‘...")
        
        # åŠ è½½éŸ³é¢‘
        wav = AudioFile(audio_path).read(
            streams=0,
            samplerate=model.samplerate,
            channels=model.audio_channels
        )
        
        # æ·»åŠ batchç»´åº¦
        ref = wav.mean(0)
        wav = (wav - ref.mean()) / ref.std()
        wav = wav.unsqueeze(0)  # (1, channels, samples)
        
        if self.config.device == "cuda":
            wav = wav.cuda()
        
        if progress_callback:
            progress_callback(0.2, "åˆ†ç¦»äººå£°ä¸­...")
        
        # æ‰§è¡Œåˆ†ç¦»
        with torch.no_grad():
            sources = apply_model(
                model,
                wav,
                shifts=self.config.shifts,
                overlap=self.config.overlap,
                progress=True,
                device=self.config.device
            )
        
        # æå–äººå£°ï¼ˆhtdemucsè¾“å‡ºé¡ºåºï¼šdrums, bass, other, vocalsï¼‰
        # è·å–sourcesåç§°ç´¢å¼•
        source_names = model.sources
        vocals_idx = source_names.index('vocals')
        vocals = sources[0, vocals_idx]  # (channels, samples)
        
        # æ¢å¤åŸå§‹scale
        vocals = vocals * ref.std() + ref.mean()
        
        if progress_callback:
            progress_callback(0.9, "ä¿å­˜æ–‡ä»¶...")
        
        # ä¿å­˜äººå£°
        vocals = vocals.cpu().numpy()
        sf.write(output_path, vocals.T, model.samplerate)
        
        # ä¿å­˜åˆ°ç¼“å­˜
        sf.write(str(cached_path), vocals.T, model.samplerate)
        
        if progress_callback:
            progress_callback(1.0, "äººå£°åˆ†ç¦»å®Œæˆ")
        
        self.logger.info(f"äººå£°åˆ†ç¦»å®Œæˆ: {output_path}")
        return output_path
    
    def separate_vocals_segment(
        self,
        audio_array: np.ndarray,
        sr: int,
        start_sec: float,
        end_sec: float,
        buffer_sec: float = None
    ) -> np.ndarray:
        """
        æŒ‰éœ€åˆ†ç¦»æŒ‡å®šæ—¶é—´æ®µçš„äººå£°ï¼ˆå†…å­˜æ¨¡å¼ï¼‰
        
        Args:
            audio_array: å®Œæ•´éŸ³é¢‘æ•°ç»„ (samples,) æˆ– (channels, samples)
            sr: é‡‡æ ·ç‡
            start_sec: å¼€å§‹æ—¶é—´ï¼ˆç§’ï¼‰
            end_sec: ç»“æŸæ—¶é—´ï¼ˆç§’ï¼‰
            buffer_sec: å‰åç¼“å†²åŒºï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ä½¿ç”¨é…ç½®å€¼
        
        Returns:
            np.ndarray: åˆ†ç¦»åçš„äººå£°ç‰‡æ®µï¼ˆä¸å«ç¼“å†²åŒºï¼‰
        """
        from demucs.apply import apply_model
        
        if buffer_sec is None:
            buffer_sec = self.config.segment_buffer_sec
        
        model = self._load_model()
        
        # è®¡ç®—é‡‡æ ·ç‚¹èŒƒå›´ï¼ˆå«ç¼“å†²åŒºï¼‰
        buffer_samples = int(buffer_sec * sr)
        start_sample = max(0, int(start_sec * sr) - buffer_samples)
        end_sample = min(len(audio_array), int(end_sec * sr) + buffer_samples)
        
        # æå–ç‰‡æ®µ
        if audio_array.ndim == 1:
            segment = audio_array[start_sample:end_sample]
            segment = np.stack([segment, segment])  # è½¬ä¸ºç«‹ä½“å£°
        else:
            segment = audio_array[:, start_sample:end_sample]
        
        # é‡é‡‡æ ·åˆ°æ¨¡å‹è¦æ±‚çš„é‡‡æ ·ç‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if sr != model.samplerate:
            import librosa
            segment = librosa.resample(segment, orig_sr=sr, target_sr=model.samplerate)
            target_sr = model.samplerate
        else:
            target_sr = sr
        
        # è½¬ä¸ºtensor
        wav = torch.from_numpy(segment).float()
        ref = wav.mean(0)
        wav = (wav - ref.mean()) / ref.std()
        wav = wav.unsqueeze(0)
        
        if self.config.device == "cuda":
            wav = wav.cuda()
        
        # æ‰§è¡Œåˆ†ç¦»
        with torch.no_grad():
            sources = apply_model(
                model,
                wav,
                shifts=1,  # æŒ‰éœ€åˆ†ç¦»ä½¿ç”¨å¿«é€Ÿæ¨¡å¼
                overlap=self.config.overlap,
                progress=False,
                device=self.config.device
            )
        
        # æå–äººå£°
        source_names = model.sources
        vocals_idx = source_names.index('vocals')
        vocals = sources[0, vocals_idx]
        vocals = vocals * ref.std() + ref.mean()
        vocals = vocals.cpu().numpy()
        
        # é‡é‡‡æ ·å›åŸå§‹é‡‡æ ·ç‡
        if target_sr != sr:
            vocals = librosa.resample(vocals, orig_sr=target_sr, target_sr=sr)
        
        # å»é™¤ç¼“å†²åŒºï¼Œè¿”å›åŸå§‹æ—¶é—´æ®µ
        original_start = int(buffer_sec * sr) if start_sec > buffer_sec else int(start_sec * sr)
        original_duration = int((end_sec - start_sec) * sr)
        vocals = vocals[:, original_start:original_start + original_duration]
        
        # è½¬ä¸ºå•å£°é“ï¼ˆWhisperè¦æ±‚ï¼‰
        if vocals.ndim > 1:
            vocals = vocals.mean(axis=0)
        
        return vocals
    
    def detect_background_music_level(
        self,
        audio_path: str,
        audio_array: Optional[np.ndarray] = None,
        sr: int = 16000,
        duration_sec: Optional[float] = None
    ) -> Tuple[BGMLevel, List[float]]:
        """
        å¿«é€Ÿæ£€æµ‹èƒŒæ™¯éŸ³ä¹å¼ºåº¦ï¼ˆåˆ†ä½æ•°é‡‡æ ·ç­–ç•¥ï¼‰
        
        é‡‡æ ·ç­–ç•¥ï¼šå–éŸ³é¢‘æ—¶é•¿çš„ 15%ã€50%ã€85% å¤„å„æˆªå– 10 ç§’
        - 15%ï¼šæ•è· Intro ç»“æŸåçš„ä¸»æ­ŒèƒŒæ™¯éŸ³
        - 50%ï¼šæ•è·ä¸­é—´éƒ¨åˆ†
        - 85%ï¼šæ•è·ç»“å°¾å‰çš„éƒ¨åˆ†
        
        Args:
            audio_path: éŸ³é¢‘æ–‡ä»¶è·¯å¾„
            audio_array: éŸ³é¢‘æ•°ç»„ï¼ˆå¯é€‰ï¼Œç”¨äºå†…å­˜æ¨¡å¼ï¼‰
            sr: é‡‡æ ·ç‡
            duration_sec: éŸ³é¢‘æ€»æ—¶é•¿ï¼ˆå¯é€‰ï¼Œå¦‚æœaudio_arrayæä¾›åˆ™è‡ªåŠ¨è®¡ç®—ï¼‰
        
        Returns:
            Tuple[BGMLevel, List[float]]: (èƒŒæ™¯éŸ³ä¹å¼ºåº¦çº§åˆ«, å„é‡‡æ ·ç‚¹çš„BGMæ¯”ä¾‹åˆ—è¡¨)
        """
        self.logger.info("æ£€æµ‹èƒŒæ™¯éŸ³ä¹å¼ºåº¦ï¼ˆåˆ†ä½æ•°é‡‡æ ·ï¼‰...")
        
        # åŠ è½½éŸ³é¢‘
        if audio_array is None:
            import librosa
            audio_array, sr = librosa.load(audio_path, sr=sr)
        
        if duration_sec is None:
            duration_sec = len(audio_array) / sr
        
        # åˆ†ä½æ•°é‡‡æ ·ä½ç½®
        sample_positions = [0.15, 0.50, 0.85]
        sample_duration = self.config.bgm_sample_duration  # é»˜è®¤10ç§’
        
        # æ£€æŸ¥éŸ³é¢‘æ˜¯å¦è¶³å¤Ÿé•¿
        if duration_sec < sample_duration * 2:
            self.logger.warning(f"éŸ³é¢‘å¤ªçŸ­({duration_sec:.1f}s)ï¼Œæ— æ³•å¯é æ£€æµ‹BGM")
            return BGMLevel.LIGHT, []  # ä¿å®ˆèµ·è§è¿”å›LIGHT
        
        ratios = []
        
        for pos in sample_positions:
            start_time = duration_sec * pos
            
            # ç¡®ä¿ä¸è¶…å‡ºè¾¹ç•Œ
            if start_time + sample_duration > duration_sec:
                start_time = duration_sec - sample_duration
            if start_time < 0:
                start_time = 0
            
            try:
                # åˆ†ç¦»è¿™ä¸€æ®µ
                vocals = self.separate_vocals_segment(
                    audio_array, sr,
                    start_sec=start_time,
                    end_sec=start_time + sample_duration,
                    buffer_sec=0.5  # æ£€æµ‹æ—¶ç”¨è¾ƒçŸ­ç¼“å†²
                )
                
                # è·å–åŸå§‹ç‰‡æ®µ
                start_sample = int(start_time * sr)
                end_sample = int((start_time + sample_duration) * sr)
                original = audio_array[start_sample:end_sample]
                
                # è®¡ç®—BGMèƒ½é‡æ¯”ï¼ˆä½¿ç”¨æ”¹è¿›çš„ç®—æ³•ï¼‰
                bgm_ratio = self._calculate_bgm_ratio(original, vocals)
                ratios.append(bgm_ratio)
                
                self.logger.debug(
                    f"é‡‡æ ·ç‚¹ {pos*100:.0f}% ({start_time:.1f}s): BGMæ¯”ä¾‹={bgm_ratio:.2f}"
                )
                    
            except Exception as e:
                self.logger.warning(f"é‡‡æ ·ç‚¹ {pos*100:.0f}% æ£€æµ‹å¤±è´¥: {e}")
                continue
        
        if not ratios:
            return BGMLevel.LIGHT, []  # é»˜è®¤å‡è®¾æœ‰è½»å¾®BGM
        
        # å†³ç­–é€»è¾‘ï¼šä½¿ç”¨æœ€å¤§å€¼åˆ¤æ–­ï¼ˆåªè¦æœ‰ä¸€å¤„BGMå¾ˆé‡ï¼Œå°±è§†ä¸ºHeavyï¼‰
        avg_ratio = np.mean(ratios)
        max_ratio = np.max(ratios)
        
        self.logger.info(
            f"BGMæ£€æµ‹å®Œæˆ: æ¯”ä¾‹={ratios}, å¹³å‡={avg_ratio:.2f}, æœ€å¤§={max_ratio:.2f}"
        )
        
        # ä½¿ç”¨max_ratioä½œä¸ºä¸»è¦åˆ¤æ–­ä¾æ®
        if max_ratio > self.config.bgm_heavy_threshold:  # é»˜è®¤0.6
            return BGMLevel.HEAVY, ratios
        elif max_ratio > self.config.bgm_light_threshold:  # é»˜è®¤0.2
            return BGMLevel.LIGHT, ratios
        else:
            return BGMLevel.NONE, ratios
    
    def _calculate_bgm_ratio(
        self, 
        original: np.ndarray, 
        vocals: np.ndarray
    ) -> float:
        """
        è®¡ç®— BGM èƒ½é‡å æ¯”
        
        é€»è¾‘ï¼š(åŸéŸ³é¢‘èƒ½é‡ - äººå£°èƒ½é‡) / åŸéŸ³é¢‘èƒ½é‡
        
        æ³¨æ„ï¼šDemucsåˆ†ç¦»å‡ºçš„vocalsèƒ½é‡å¯èƒ½ä¸åŸå§‹ä¸å®Œå…¨ä¸€è‡´ï¼Œ
        è¿™é‡Œä½¿ç”¨RMSèƒ½é‡æ¯”ä½œä¸ºè¿‘ä¼¼ä¼°ç®—ã€‚
        
        Args:
            original: åŸå§‹æ··åˆéŸ³é¢‘
            vocals: åˆ†ç¦»åçš„äººå£°
        
        Returns:
            float: BGMèƒ½é‡å æ¯” (0.0-1.0)ï¼Œè¶Šé«˜è¡¨ç¤ºBGMè¶Šå¼º
        """
        # ç¡®ä¿é•¿åº¦ä¸€è‡´
        min_len = min(len(original), len(vocals))
        original = original[:min_len]
        vocals = vocals[:min_len]
        
        # è®¡ç®—å‡æ–¹æ ¹èƒ½é‡ (RMS)
        rms_orig = np.sqrt(np.mean(original ** 2))
        rms_voc = np.sqrt(np.mean(vocals ** 2))
        
        # å¦‚æœåŸéŸ³å°±å¾ˆå°ï¼ˆé™éŸ³ç‰‡æ®µï¼‰ï¼Œè¿”å›0
        if rms_orig < 0.01:
            return 0.0
        
        # è®¡ç®—éäººå£°éƒ¨åˆ†çš„èƒ½é‡å æ¯”ï¼ˆè¿‘ä¼¼èƒŒæ™¯éŸ³ï¼‰
        # å‡è®¾ Energy_Total â‰ˆ Energy_Vocal + Energy_BGM
        # BGM_ratio â‰ˆ 1 - (Vocal_RMS / Total_RMS)
        bgm_ratio = 1.0 - (rms_voc / (rms_orig + 1e-6))
        
        return max(0.0, min(1.0, bgm_ratio))  # é’³åˆ¶åœ¨0-1èŒƒå›´
    
    def _get_cache_key(self, audio_path: str, mode: str) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        path_hash = hashlib.md5(audio_path.encode()).hexdigest()[:16]
        mtime = int(os.path.getmtime(audio_path))
        return f"{path_hash}_{mtime}_{mode}"


# å…¨å±€å•ä¾‹
_demucs_service: Optional[DemucsService] = None


def get_demucs_service() -> DemucsService:
    """è·å–DemucsæœåŠ¡å•ä¾‹"""
    global _demucs_service
    if _demucs_service is None:
        _demucs_service = DemucsService()
    return _demucs_service
```

### 2. TranscriptionService ä¿®æ”¹

#### 2.1 æ–°å¢é…ç½®é¡¹

```python
# åœ¨ VADConfig åé¢æ·»åŠ 

class BreakToGlobalSeparation(Exception):
    """
    ç†”æ–­å¼‚å¸¸ï¼šè§¦å‘æ—¶éœ€è¦å‡çº§ä¸ºå…¨å±€äººå£°åˆ†ç¦»æ¨¡å¼
    """
    pass


@dataclass
class DemucsIntegrationConfig:
    """Demucsé›†æˆé…ç½®"""
    enabled: bool = True                    # æ˜¯å¦å¯ç”¨Demucs
    mode: str = "auto"                      # æ¨¡å¼: "auto" | "always" | "never" | "on_demand"
    
    # é‡è¯•é˜ˆå€¼
    retry_threshold_logprob: float = -0.8   # é‡è¯•é˜ˆå€¼ï¼ˆavg_logprobï¼‰
    retry_threshold_no_speech: float = 0.6  # é‡è¯•é˜ˆå€¼ï¼ˆno_speech_probï¼‰
    max_retries: int = 1                    # æ¯æ®µæœ€å¤§é‡è¯•æ¬¡æ•°
    
    # åŠ¨æ€ç†”æ–­é…ç½®
    enable_circuit_breaker: bool = True     # æ˜¯å¦å¯ç”¨åŠ¨æ€ç†”æ–­
    consecutive_retry_threshold: int = 3    # è¿ç»­é‡è¯•è§¦å‘ç†”æ–­çš„é˜ˆå€¼
    total_retry_ratio_threshold: float = 0.2  # æ€»é‡è¯•æ¯”ä¾‹è§¦å‘ç†”æ–­çš„é˜ˆå€¼ï¼ˆ20%ï¼‰


@dataclass
class CircuitBreakerState:
    """
    ç†”æ–­å™¨çŠ¶æ€ï¼ˆç”¨äºè·Ÿè¸ªè½¬å½•è¿‡ç¨‹ä¸­çš„é‡è¯•æƒ…å†µï¼‰
    """
    consecutive_retries: int = 0            # è¿ç»­é‡è¯•è®¡æ•°
    total_retries: int = 0                  # æ€»é‡è¯•æ¬¡æ•°
    total_segments: int = 0                 # æ€»æ®µè½æ•°
    processed_segments: int = 0             # å·²å¤„ç†æ®µè½æ•°
    
    def record_retry(self):
        """è®°å½•ä¸€æ¬¡é‡è¯•"""
        self.consecutive_retries += 1
        self.total_retries += 1
    
    def record_success(self):
        """è®°å½•ä¸€æ¬¡æˆåŠŸï¼ˆé‡ç½®è¿ç»­è®¡æ•°ï¼‰"""
        self.consecutive_retries = 0
        self.processed_segments += 1
    
    def should_break(self, config: DemucsIntegrationConfig) -> bool:
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘ç†”æ–­
        
        ç†”æ–­æ¡ä»¶ï¼ˆæ»¡è¶³ä»»ä¸€å³ç†”æ–­ï¼‰ï¼š
        1. è¿ç»­ N ä¸ª segment éƒ½è§¦å‘é‡è¯•ï¼ˆé»˜è®¤N=3ï¼‰
        2. æ€»é‡è¯•æ¯”ä¾‹è¶…è¿‡é˜ˆå€¼ï¼ˆé»˜è®¤20%ï¼‰
        """
        if not config.enable_circuit_breaker:
            return False
        
        # æ¡ä»¶1ï¼šè¿ç»­é‡è¯•æ¬¡æ•°
        if self.consecutive_retries >= config.consecutive_retry_threshold:
            return True
        
        # æ¡ä»¶2ï¼šæ€»é‡è¯•æ¯”ä¾‹ï¼ˆè‡³å°‘å¤„ç†5ä¸ªsegmentåæ‰æ£€æŸ¥ï¼‰
        if self.processed_segments >= 5:
            retry_ratio = self.total_retries / self.processed_segments
            if retry_ratio >= config.total_retry_ratio_threshold:
                return True
        
        return False
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "consecutive_retries": self.consecutive_retries,
            "total_retries": self.total_retries,
            "total_segments": self.total_segments,
            "processed_segments": self.processed_segments,
            "retry_ratio": self.total_retries / max(1, self.processed_segments)
        }
```

#### 2.2 ä¿®æ”¹è½¬å½•æ–¹æ³•

```python
def _transcribe_segment_with_retry(
    self,
    seg_meta: Dict,
    model,
    job: JobState,
    audio_array: Optional[np.ndarray] = None,
    demucs_config: Optional[DemucsIntegrationConfig] = None,
    circuit_breaker: Optional[CircuitBreakerState] = None
) -> Optional[Dict]:
    """
    å¸¦é‡è¯•çš„è½¬å½•æ–¹æ³•ï¼ˆæ”¯æŒDemucsäººå£°åˆ†ç¦»é‡è¯• + åŠ¨æ€ç†”æ–­ï¼‰
    
    æµç¨‹ï¼š
    1. é¦–æ¬¡è½¬å½•ï¼ˆä½¿ç”¨åŸå§‹éŸ³é¢‘ï¼‰
    2. æ£€æŸ¥ç½®ä¿¡åº¦
    3. å¦‚æœç½®ä¿¡åº¦ä½ï¼Œä½¿ç”¨Demucsåˆ†ç¦»äººå£°åé‡è¯•
    4. æ›´æ–°ç†”æ–­å™¨çŠ¶æ€
    5. æ£€æŸ¥æ˜¯å¦è§¦å‘ç†”æ–­
    6. è¿”å›ç½®ä¿¡åº¦æ›´é«˜çš„ç»“æœ
    
    Raises:
        BreakToGlobalSeparation: å½“è§¦å‘ç†”æ–­æ¡ä»¶æ—¶æŠ›å‡º
    """
    if demucs_config is None:
        demucs_config = DemucsIntegrationConfig()
    
    # é¦–æ¬¡è½¬å½•
    result = self._transcribe_segment(seg_meta, model, job, audio_array)
    
    if not result or not demucs_config.enabled:
        if circuit_breaker:
            circuit_breaker.record_success()
        return result
    
    # æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
    needs_retry = self._check_transcription_confidence(
        result,
        demucs_config.retry_threshold_logprob,
        demucs_config.retry_threshold_no_speech
    )
    
    if not needs_retry:
        # ä¸éœ€è¦é‡è¯•ï¼Œè®°å½•æˆåŠŸ
        if circuit_breaker:
            circuit_breaker.record_success()
        return result
    
    # ========== éœ€è¦é‡è¯•çš„é€»è¾‘ ==========
    self.logger.info(f"æ®µè½ {seg_meta['index']} ç½®ä¿¡åº¦ä½ï¼Œå°è¯•äººå£°åˆ†ç¦»é‡è¯•")
    
    # æ›´æ–°ç†”æ–­å™¨çŠ¶æ€
    if circuit_breaker:
        circuit_breaker.record_retry()
        
        # æ£€æŸ¥æ˜¯å¦è§¦å‘ç†”æ–­
        if circuit_breaker.should_break(demucs_config):
            stats = circuit_breaker.get_stats()
            self.logger.warning(
                f"ğŸš¨ è§¦å‘ç†”æ–­ï¼è¿ç»­é‡è¯•={stats['consecutive_retries']}, "
                f"æ€»é‡è¯•æ¯”ä¾‹={stats['retry_ratio']:.1%}"
            )
            raise BreakToGlobalSeparation(
                f"è¿ç»­{stats['consecutive_retries']}æ®µéœ€è¦Demucsé‡è¯•ï¼Œ"
                f"å»ºè®®å‡çº§ä¸ºå…¨å±€äººå£°åˆ†ç¦»æ¨¡å¼"
            )
    
    try:
        from services.demucs_service import get_demucs_service
        demucs = get_demucs_service()
        
        # æå–è¯¥æ®µçš„äººå£°
        start_sec = seg_meta['start']
        end_sec = seg_meta['end']
        
        if audio_array is not None:
            # å†…å­˜æ¨¡å¼
            vocals = demucs.separate_vocals_segment(
                audio_array, 
                sr=16000, 
                start_sec=start_sec, 
                end_sec=end_sec
            )
            
            # æ„é€ ä¸´æ—¶seg_meta
            retry_seg = seg_meta.copy()
            retry_seg['start'] = 0  # å› ä¸ºvocalså·²ç»æ˜¯åˆ‡ç‰‡
            retry_seg['end'] = len(vocals) / 16000
            
            # é‡æ–°è½¬å½•
            retry_result = self._transcribe_segment_in_memory(
                vocals, 
                retry_seg, 
                model, 
                job,
                is_vocals=True  # æ ‡è®°æ˜¯äººå£°
            )
        else:
            # ç¡¬ç›˜æ¨¡å¼ï¼šæš‚ä¸æ”¯æŒï¼Œè¿”å›åŸç»“æœ
            self.logger.warning("ç¡¬ç›˜æ¨¡å¼æš‚ä¸æ”¯æŒDemucsé‡è¯•")
            return result
        
        if retry_result:
            # æ ¡æ­£æ—¶é—´åç§»ï¼ˆæ¢å¤åˆ°åŸå§‹æ—¶é—´è½´ï¼‰
            original_start = seg_meta['start']
            for seg in retry_result.get('segments', []):
                seg['start'] += original_start
                seg['end'] += original_start
            
            # æ¯”è¾ƒä¸¤æ¬¡ç»“æœï¼Œè¿”å›æ›´å¥½çš„
            if self._is_better_result(retry_result, result):
                self.logger.info(f"æ®µè½ {seg_meta['index']} é‡è¯•æˆåŠŸï¼Œä½¿ç”¨åˆ†ç¦»åçš„ç»“æœ")
                retry_result['used_demucs'] = True
                return retry_result
        
    except Exception as e:
        self.logger.warning(f"Demucsé‡è¯•å¤±è´¥: {e}")
    
    return result


def _check_transcription_confidence(
    self,
    result: Dict,
    logprob_threshold: float,
    no_speech_threshold: float
) -> bool:
    """
    æ£€æŸ¥è½¬å½•ç»“æœçš„ç½®ä¿¡åº¦
    
    Returns:
        bool: Trueè¡¨ç¤ºç½®ä¿¡åº¦ä½ï¼Œéœ€è¦é‡è¯•
    """
    segments = result.get('segments', [])
    
    if not segments:
        return True  # æ²¡æœ‰è¯†åˆ«å‡ºå†…å®¹ï¼Œéœ€è¦é‡è¯•
    
    # è®¡ç®—å¹³å‡ç½®ä¿¡åº¦
    total_logprob = 0
    total_no_speech = 0
    count = 0
    
    for seg in segments:
        if 'avg_logprob' in seg:
            total_logprob += seg['avg_logprob']
            count += 1
        if 'no_speech_prob' in seg:
            total_no_speech += seg['no_speech_prob']
    
    if count == 0:
        return False  # æ²¡æœ‰ç½®ä¿¡åº¦ä¿¡æ¯ï¼Œä¸é‡è¯•
    
    avg_logprob = total_logprob / count
    avg_no_speech = total_no_speech / count if count > 0 else 0
    
    # åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
    if avg_logprob < logprob_threshold:
        self.logger.debug(f"avg_logprob={avg_logprob:.2f} < {logprob_threshold}, éœ€è¦é‡è¯•")
        return True
    
    if avg_no_speech > no_speech_threshold:
        self.logger.debug(f"no_speech_prob={avg_no_speech:.2f} > {no_speech_threshold}, éœ€è¦é‡è¯•")
        return True
    
    return False


def _is_better_result(self, new_result: Dict, old_result: Dict) -> bool:
    """
    æ¯”è¾ƒä¸¤ä¸ªè½¬å½•ç»“æœï¼Œåˆ¤æ–­æ–°ç»“æœæ˜¯å¦æ›´å¥½
    """
    new_segments = new_result.get('segments', [])
    old_segments = old_result.get('segments', [])
    
    # å¦‚æœæ–°ç»“æœæ²¡æœ‰å†…å®¹ï¼Œæ—§çš„æ›´å¥½
    if not new_segments:
        return False
    
    # å¦‚æœæ—§ç»“æœæ²¡æœ‰å†…å®¹ï¼Œæ–°çš„æ›´å¥½
    if not old_segments:
        return True
    
    # æ¯”è¾ƒå¹³å‡logprob
    def get_avg_logprob(segments):
        logprobs = [s.get('avg_logprob', -1) for s in segments if 'avg_logprob' in s]
        return np.mean(logprobs) if logprobs else -1
    
    new_logprob = get_avg_logprob(new_segments)
    old_logprob = get_avg_logprob(old_segments)
    
    # æ–°ç»“æœçš„logprobæ›´é«˜ï¼ˆæ›´æ¥è¿‘0ï¼‰åˆ™æ›´å¥½
    return new_logprob > old_logprob
```

#### 2.3 ä¸»æµç¨‹ç†”æ–­å¤„ç†

```python
def _process_transcription_with_circuit_breaker(
    self,
    job: JobState,
    segments: List[Dict],
    model,
    audio_array: np.ndarray,
    demucs_config: DemucsIntegrationConfig
) -> List[Dict]:
    """
    å¸¦ç†”æ–­æœºåˆ¶çš„è½¬å½•ä¸»æµç¨‹
    
    æµç¨‹ï¼š
    1. åˆå§‹åŒ–ç†”æ–­å™¨
    2. é€æ®µè½¬å½•ï¼ˆå¸¦é‡è¯•ï¼‰
    3. å¦‚æœè§¦å‘ç†”æ–­ â†’ å‡çº§ä¸ºå…¨å±€åˆ†ç¦»æ¨¡å¼ï¼Œé‡æ–°å¼€å§‹
    4. è¿”å›æœ€ç»ˆç»“æœ
    """
    max_global_retries = 1  # æœ€å¤šè§¦å‘ä¸€æ¬¡å…¨å±€å‡çº§
    global_retry_count = 0
    
    while global_retry_count <= max_global_retries:
        try:
            # åˆå§‹åŒ–ç†”æ–­å™¨
            circuit_breaker = CircuitBreakerState(total_segments=len(segments))
            
            results = []
            for seg in segments:
                result = self._transcribe_segment_with_retry(
                    seg,
                    model,
                    job,
                    audio_array=audio_array,
                    demucs_config=demucs_config,
                    circuit_breaker=circuit_breaker
                )
                if result:
                    results.append(result)
            
            # æ­£å¸¸å®Œæˆï¼Œè¿”å›ç»“æœ
            stats = circuit_breaker.get_stats()
            self.logger.info(
                f"è½¬å½•å®Œæˆ: {stats['processed_segments']}æ®µ, "
                f"é‡è¯•{stats['total_retries']}æ¬¡ ({stats['retry_ratio']:.1%})"
            )
            return results
            
        except BreakToGlobalSeparation as e:
            global_retry_count += 1
            self.logger.warning(f"ğŸš¨ ç†”æ–­è§¦å‘ (ç¬¬{global_retry_count}æ¬¡): {e}")
            
            if global_retry_count > max_global_retries:
                self.logger.error("å·²è¾¾åˆ°æœ€å¤§å…¨å±€é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨å½“å‰ç»“æœ")
                break
            
            # ========== å‡çº§ä¸ºå…¨å±€åˆ†ç¦»æ¨¡å¼ ==========
            self.logger.info("ğŸ“¢ å‡çº§ä¸ºå…¨å±€äººå£°åˆ†ç¦»æ¨¡å¼ï¼Œé‡æ–°å¤„ç†...")
            
            # 1. ä¸¢å¼ƒå·²è½¬å½•å†…å®¹ï¼ˆresultsåœ¨å¼‚å¸¸åä¸¢å¼ƒï¼‰
            
            # 2. æ‰§è¡Œå…¨å±€äººå£°åˆ†ç¦»
            from services.demucs_service import get_demucs_service
            demucs = get_demucs_service()
            
            # ä¿å­˜åŸå§‹éŸ³é¢‘åˆ°ä¸´æ—¶æ–‡ä»¶ï¼ˆå…¨å±€åˆ†ç¦»éœ€è¦æ–‡ä»¶è·¯å¾„ï¼‰
            import tempfile
            import soundfile as sf
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as f:
                temp_path = f.name
                sf.write(temp_path, audio_array, 16000)
            
            try:
                vocals_path = demucs.separate_vocals(
                    temp_path,
                    progress_callback=lambda p, m: self._update_progress(
                        job, 'demucs', p, f'å…¨å±€äººå£°åˆ†ç¦»: {m}'
                    )
                )
                
                # 3. åŠ è½½åˆ†ç¦»åçš„äººå£°
                import whisperx
                audio_array = whisperx.load_audio(vocals_path)
                
                # 4. é‡æ–°VADåˆ†æ®µï¼ˆä½¿ç”¨çº¯äººå£°ï¼‰
                segments = self._split_audio_in_memory(audio_array, sr=16000)
                
                self.logger.info(f"å…¨å±€åˆ†ç¦»å®Œæˆï¼Œé‡æ–°åˆ†æ®µ: {len(segments)}æ®µ")
                
                # 5. ç¦ç”¨åç»­çš„æŒ‰éœ€åˆ†ç¦»ï¼ˆå› ä¸ºå·²ç»æ˜¯çº¯äººå£°äº†ï¼‰
                demucs_config = DemucsIntegrationConfig(
                    enabled=False,  # ç¦ç”¨è¿›ä¸€æ­¥çš„Demucså¤„ç†
                    enable_circuit_breaker=False
                )
                
            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                import os
                os.unlink(temp_path)
            
            # ç»§ç»­å¾ªç¯ï¼Œä½¿ç”¨åˆ†ç¦»åçš„éŸ³é¢‘é‡æ–°è½¬å½•
            continue
    
    return results  # è¿”å›æœ€åä¸€æ¬¡å°è¯•çš„ç»“æœ
```

#### 2.4 å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            è½¬å½•ä¸»æµç¨‹ (å«ç†”æ–­æœºåˆ¶)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  1. éŸ³é¢‘æå– â†’ audio.wav                                                    â”‚
â”‚                                                                             â”‚
â”‚  2. BGMæ£€æµ‹ï¼ˆåˆ†ä½æ•°é‡‡æ ·: 15%, 50%, 85%ï¼‰                                     â”‚
â”‚     â”œâ”€ HEAVY â†’ ç›´æ¥å…¨å±€åˆ†ç¦» â†’ è·³åˆ° Step 3                                    â”‚
â”‚     â”œâ”€ LIGHT â†’ å¯ç”¨æŒ‰éœ€åˆ†ç¦» â†’ è·³åˆ° Step 4                                    â”‚
â”‚     â””â”€ NONE  â†’ ç¦ç”¨åˆ†ç¦»ï¼ˆä»ä¿ç•™ç†”æ–­æœºåˆ¶ï¼‰â†’ è·³åˆ° Step 4                        â”‚
â”‚                                                                             â”‚
â”‚  3. å…¨å±€äººå£°åˆ†ç¦»                                                             â”‚
â”‚     â””â”€ DemucsService.separate_vocals() â†’ vocals.wav                         â”‚
â”‚                                                                             â”‚
â”‚  4. VADåˆ†æ®µ                                                                  â”‚
â”‚     â””â”€ segments = [seg1, seg2, ...]                                         â”‚
â”‚                                                                             â”‚
â”‚  5. è½¬å½•å¾ªç¯ï¼ˆå¸¦ç†”æ–­å™¨ï¼‰                                                      â”‚
â”‚     â”Œâ”€ for seg in segments:                                                 â”‚
â”‚     â”‚   â”œâ”€ é¦–æ¬¡è½¬å½•                                                          â”‚
â”‚     â”‚   â”œâ”€ æ£€æŸ¥ç½®ä¿¡åº¦                                                        â”‚
â”‚     â”‚   â”‚   â”œâ”€ OK â†’ circuit_breaker.record_success()                        â”‚
â”‚     â”‚   â”‚   â””â”€ ä½ â†’ circuit_breaker.record_retry()                          â”‚
â”‚     â”‚   â”‚        â”œâ”€ æ£€æŸ¥ç†”æ–­æ¡ä»¶                                             â”‚
â”‚     â”‚   â”‚        â”‚   â”œâ”€ è¿ç»­3æ®µé‡è¯•? â†’ ğŸš¨ BREAK                              â”‚
â”‚     â”‚   â”‚        â”‚   â””â”€ æ€»é‡è¯•>20%?  â†’ ğŸš¨ BREAK                              â”‚
â”‚     â”‚   â”‚        â””â”€ æŒ‰éœ€Demucsåˆ†ç¦» â†’ é‡è¯•è½¬å½•                                 â”‚
â”‚     â”‚   â””â”€ results.append(result)                                           â”‚
â”‚     â””â”€ æ­£å¸¸å®Œæˆ â†’ è·³åˆ° Step 6                                                â”‚
â”‚                                                                             â”‚
â”‚  5.5 ç†”æ–­å¤„ç† (catch BreakToGlobalSeparation)                               â”‚
â”‚     â”œâ”€ ä¸¢å¼ƒå·²è½¬å½•å†…å®¹                                                        â”‚
â”‚     â”œâ”€ å…¨å±€äººå£°åˆ†ç¦»                                                          â”‚
â”‚     â”œâ”€ é‡æ–°VADåˆ†æ®µ                                                           â”‚
â”‚     â”œâ”€ ç¦ç”¨åç»­Demucsï¼ˆå·²æ˜¯çº¯äººå£°ï¼‰                                           â”‚
â”‚     â””â”€ å›åˆ° Step 5 é‡æ–°è½¬å½•                                                  â”‚
â”‚                                                                             â”‚
â”‚  6. å¯¹é½ & ç”ŸæˆSRT                                                           â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ æ–‡ä»¶å˜æ›´æ¸…å•

### æ–°å¢æ–‡ä»¶

| æ–‡ä»¶ | è¯´æ˜ |
|------|------|
| `backend/app/services/demucs_service.py` | Demucsäººå£°åˆ†ç¦»æœåŠ¡ |
| `docs/Demucsäººå£°åˆ†ç¦»é›†æˆæ–¹æ¡ˆ.md` | æœ¬æ–‡æ¡£ |

### ä¿®æ”¹æ–‡ä»¶

| æ–‡ä»¶ | ä¿®æ”¹å†…å®¹ |
|------|----------|
| `backend/app/services/transcription_service.py` | æ·»åŠ Demucsé›†æˆé€»è¾‘ |
| `backend/requirements.txt` | æ·»åŠ  `demucs>=4.0.0` |

---

## ğŸ”§ é…ç½®è¯´æ˜

### requirements.txt æ·»åŠ 

```
demucs>=4.0.0
```

### å‰ç«¯è®¾ç½®ï¼ˆé¢„ç•™ï¼‰

```json
{
  "demucs": {
    "enabled": true,
    "mode": "auto",
    "retry_threshold_logprob": -0.8,
    "retry_threshold_no_speech": 0.6,
    "circuit_breaker": {
      "enabled": true,
      "consecutive_threshold": 3,
      "ratio_threshold": 0.2
    },
    "bgm_detection": {
      "light_threshold": 0.2,
      "heavy_threshold": 0.6
    }
  }
}
```

### æ¨¡å¼è¯´æ˜

| æ¨¡å¼ | è¯´æ˜ | ä½¿ç”¨åœºæ™¯ |
|------|------|---------|
| `auto` | æ™ºèƒ½æ£€æµ‹BGMå¼ºåº¦ï¼Œè‡ªåŠ¨é€‰æ‹©ç­–ç•¥ï¼Œå¯ç”¨ç†”æ–­ | **é»˜è®¤æ¨è** |
| `always` | å§‹ç»ˆè¿›è¡Œå…¨å±€äººå£°åˆ†ç¦» | MVã€æ¸¸æˆç›´æ’­ç­‰å·²çŸ¥é‡BGM |
| `on_demand` | ä»…æŒ‰éœ€åˆ†ç¦»ä½ç½®ä¿¡åº¦æ®µè½ï¼Œä¸åšåˆå§‹æ£€æµ‹ | è½»é‡å¤„ç† |
| `never` | å®Œå…¨ç¦ç”¨Demucs | çº¯å¯¹è¯ã€æ’­å®¢ç­‰ |

---

## ğŸ“Š æ€§èƒ½é¢„ä¼°

| åœºæ™¯ | æ— Demucs | æœ‰Demucsï¼ˆæŒ‰éœ€ï¼‰ | æœ‰Demucsï¼ˆå…¨å±€ï¼‰ | ç†”æ–­å‡çº§ |
|------|----------|-----------------|-----------------|---------|
| 10åˆ†é’Ÿçº¯å¯¹è¯ | 2åˆ†é’Ÿ | 2åˆ†é’Ÿ | 4åˆ†é’Ÿ | - |
| 10åˆ†é’Ÿè½»BGM | 2åˆ†é’Ÿ | 2.5åˆ†é’Ÿï¼ˆ3æ®µé‡è¯•ï¼‰ | 4åˆ†é’Ÿ | - |
| 10åˆ†é’Ÿé‡BGM | 2åˆ†é’Ÿï¼ˆå‡†ç¡®ç‡ä½ï¼‰ | 3åˆ†é’Ÿï¼ˆ8æ®µé‡è¯•ï¼‰ | 4åˆ†é’Ÿï¼ˆæ¨èï¼‰ | - |
| 10åˆ†é’ŸMV | 2åˆ†é’Ÿï¼ˆå‡ ä¹æ— æ³•ç”¨ï¼‰ | 4åˆ†é’Ÿ | 4åˆ†é’Ÿï¼ˆæ¨èï¼‰ | - |
| 10åˆ†é’Ÿçªå‘BGM | 2åˆ†é’Ÿï¼ˆéƒ¨åˆ†å¤±è´¥ï¼‰ | ~5åˆ†é’Ÿï¼ˆè§¦å‘ç†”æ–­ï¼‰ | 4åˆ†é’Ÿ | å…ˆ2åˆ†é’Ÿå°è¯•ï¼Œç†”æ–­å+2åˆ†é’Ÿ |

### ç†”æ–­æœºåˆ¶çš„æ€§èƒ½å½±å“

| æƒ…å†µ | è¡Œä¸º | é¢å¤–è€—æ—¶ |
|------|------|---------|
| é‡‡æ ·æ£€æµ‹æˆåŠŸ | åˆå§‹æ£€æµ‹å°±åˆ¤å®šHeavyï¼Œç›´æ¥å…¨å±€åˆ†ç¦» | ä»…å…¨å±€åˆ†ç¦»æ—¶é—´ |
| é‡‡æ ·æ£€æµ‹æ¼ç½‘ | è½¬å½•ä¸­è§¦å‘ç†”æ–­ï¼Œä¸¢å¼ƒç»“æœé‡æ¥ | æµªè´¹çš„è½¬å½•æ—¶é—´ + å…¨å±€åˆ†ç¦»æ—¶é—´ |
| æ— BGM | ä¸è§¦å‘ä»»ä½•Demucs | 0 |

**å»ºè®®**ï¼šå¯¹äºå·²çŸ¥BGMè¾ƒé‡çš„è§†é¢‘ï¼ˆå¦‚æ¸¸æˆå®å†µã€MVï¼‰ï¼Œå»ºè®®åœ¨è®¾ç½®ä¸­ç›´æ¥é€‰æ‹©"å…¨å±€åˆ†ç¦»"æ¨¡å¼ï¼Œé¿å…ç†”æ–­å¸¦æ¥çš„é¢å¤–è€—æ—¶ã€‚

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

```python
# æµ‹è¯•1: åŸºæœ¬äººå£°åˆ†ç¦»
def test_demucs_basic():
    from services.demucs_service import get_demucs_service
    demucs = get_demucs_service()
    
    output = demucs.separate_vocals("test_audio.wav")
    assert os.path.exists(output)
    
# æµ‹è¯•2: BGMæ£€æµ‹ï¼ˆåˆ†ä½æ•°é‡‡æ ·ï¼‰
def test_bgm_detection():
    from services.demucs_service import get_demucs_service, BGMLevel
    demucs = get_demucs_service()
    
    # çº¯å¯¹è¯è§†é¢‘
    level, ratios = demucs.detect_background_music_level("dialogue.wav")
    assert level == BGMLevel.NONE
    assert len(ratios) == 3  # 15%, 50%, 85% ä¸‰ä¸ªé‡‡æ ·ç‚¹
    
    # MVï¼ˆåº”ä½¿ç”¨max_ratioåˆ¤æ–­ï¼‰
    level, ratios = demucs.detect_background_music_level("music_video.wav")
    assert level == BGMLevel.HEAVY
    assert max(ratios) > 0.6

# æµ‹è¯•3: æŒ‰éœ€åˆ†ç¦»
def test_segment_separation():
    from services.demucs_service import get_demucs_service
    import numpy as np
    
    demucs = get_demucs_service()
    
    # æ¨¡æ‹Ÿ10ç§’éŸ³é¢‘
    audio = np.random.randn(160000).astype(np.float32)
    
    vocals = demucs.separate_vocals_segment(
        audio, sr=16000,
        start_sec=2.0, end_sec=5.0
    )
    
    # åº”è¯¥è¿”å›çº¦3ç§’çš„éŸ³é¢‘
    assert abs(len(vocals) - 48000) < 1600  # å…è®¸å°è¯¯å·®

# æµ‹è¯•4: ç†”æ–­å™¨çŠ¶æ€
def test_circuit_breaker():
    from services.transcription_service import (
        CircuitBreakerState, 
        DemucsIntegrationConfig
    )
    
    config = DemucsIntegrationConfig(
        consecutive_retry_threshold=3,
        total_retry_ratio_threshold=0.2
    )
    breaker = CircuitBreakerState(total_segments=20)
    
    # æ¨¡æ‹Ÿè¿ç»­é‡è¯•
    breaker.record_retry()
    assert not breaker.should_break(config)
    breaker.record_retry()
    assert not breaker.should_break(config)
    breaker.record_retry()  # ç¬¬3æ¬¡
    assert breaker.should_break(config)  # åº”è¯¥è§¦å‘ç†”æ–­

# æµ‹è¯•5: ç†”æ–­å™¨æ¯”ä¾‹è§¦å‘
def test_circuit_breaker_ratio():
    from services.transcription_service import (
        CircuitBreakerState, 
        DemucsIntegrationConfig
    )
    
    config = DemucsIntegrationConfig(
        consecutive_retry_threshold=10,  # é«˜é˜ˆå€¼ï¼Œä¸ä¼šè§¦å‘è¿ç»­ç†”æ–­
        total_retry_ratio_threshold=0.2
    )
    breaker = CircuitBreakerState(total_segments=10)
    
    # å¤„ç†5æ®µï¼Œå…¶ä¸­2æ®µé‡è¯•ï¼ˆæ¯”ä¾‹40% > 20%ï¼‰
    breaker.record_success()  # 1
    breaker.record_retry(); breaker.record_success()  # 2 (é‡è¯•åæˆåŠŸ)
    breaker.record_success()  # 3
    breaker.record_retry(); breaker.record_success()  # 4 (é‡è¯•åæˆåŠŸ)
    breaker.record_success()  # 5
    
    # æ­¤æ—¶ retry_ratio = 2/5 = 40% > 20%
    assert breaker.should_break(config)
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **é¦–æ¬¡ä½¿ç”¨**ä¼šè‡ªåŠ¨ä¸‹è½½æ¨¡å‹ï¼ˆ~80MBï¼‰ï¼Œéœ€è¦ç½‘ç»œè¿æ¥
2. **GPUæ˜¾å­˜**ï¼šDemucséœ€è¦çº¦2-4GBæ˜¾å­˜ï¼Œä¸Whisperå…±äº«æ—¶æ³¨æ„æ˜¾å­˜ç®¡ç†
3. **CPUæ¨¡å¼**ï¼šæ”¯æŒçº¯CPUè¿è¡Œï¼Œä½†é€Ÿåº¦çº¦ä¸ºGPUçš„1/5
4. **éŸ³é¢‘æ ¼å¼**ï¼šæ”¯æŒWAVã€MP3ã€FLACç­‰å¸¸è§æ ¼å¼

---

## ğŸ¯ å…³é”®è®¾è®¡å†³ç­–

### ä¸ºä»€ä¹ˆç”¨åˆ†ä½æ•°é‡‡æ ·è€Œä¸æ˜¯éšæœº/å‡åŒ€é‡‡æ ·ï¼Ÿ

| é‡‡æ ·æ–¹å¼ | é—®é¢˜ |
|---------|------|
| éšæœºé‡‡æ · | ä¸å¯å¤ç°ï¼Œå¯èƒ½å…¨éƒ¨è½åœ¨é™éŸ³æ®µ |
| å‡åŒ€é‡‡æ ·ï¼ˆ0s, 60s, 120s...ï¼‰ | å¯èƒ½æ°å¥½é¿å¼€æ‰€æœ‰BGMæ®µ |
| **åˆ†ä½æ•°é‡‡æ ·ï¼ˆ15%, 50%, 85%ï¼‰** | âœ… è¦†ç›–Introåã€ä¸­æ®µã€ç»“å°¾å‰ï¼Œæ¦‚ç‡æœ€é«˜å‘½ä¸­BGM |

### ä¸ºä»€ä¹ˆç”¨ max_ratio è€Œä¸æ˜¯ avg_ratio åˆ¤æ–­ï¼Ÿ

```
åœºæ™¯ï¼šè§†é¢‘å¤§éƒ¨åˆ†æ˜¯çº¯å¯¹è¯ï¼Œä½†æœ‰ä¸€æ®µ30ç§’çš„MVæ’å…¥

avg_ratio = (0.1 + 0.1 + 0.8) / 3 = 0.33 â†’ åˆ¤å®šä¸º LIGHT âŒ
max_ratio = max(0.1, 0.1, 0.8) = 0.8 â†’ åˆ¤å®šä¸º HEAVY âœ…
```

**ç»“è®º**ï¼šåªè¦æœ‰ä¸€å¤„BGMå¾ˆé‡ï¼Œå°±åº”è¯¥é‡‡ç”¨å…¨å±€åˆ†ç¦»ï¼Œå¦åˆ™é‚£ä¸€æ®µä¼šä¸¥é‡å½±å“å­—å¹•è´¨é‡ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦åŠ¨æ€ç†”æ–­æœºåˆ¶ï¼Ÿ

å³ä½¿é‡‡æ ·äº†3ä¸ªç‚¹ï¼ˆ15%ã€50%ã€85%ï¼‰ï¼Œä»å¯èƒ½å‡ºç°ï¼š
- è§†é¢‘ç¬¬4åˆ†é’Ÿçªç„¶æ’å…¥30ç§’çš„æ¿€çƒˆæ‘‡æ»šä¹
- å‰ä¸­åéƒ½å¾ˆå¹²å‡€ï¼Œä½†æŸå¤„æœ‰çªå‘BGM

**ç†”æ–­æœºåˆ¶çš„ä»·å€¼**ï¼š
1. å®æ—¶ç›‘æ§è½¬å½•è´¨é‡
2. å‘ç°æŒç»­ä½ç½®ä¿¡åº¦æ—¶åŠæ—¶æ­¢æŸ
3. è‡ªåŠ¨å‡çº§ä¸ºå…¨å±€åˆ†ç¦»ï¼Œé¿å…"ä¸€æ®µæ®µä¿®è¡¥"çš„ä½æ•ˆç­–ç•¥

### ç†”æ–­é˜ˆå€¼çš„é€‰æ‹©ä¾æ®

| é˜ˆå€¼ | å€¼ | åŸå›  |
|------|-----|------|
| è¿ç»­é‡è¯•é˜ˆå€¼ | 3 | è¿ç»­3æ®µéƒ½éœ€è¦Demucsè¯´æ˜é—®é¢˜æŒç»­å­˜åœ¨ |
| æ€»é‡è¯•æ¯”ä¾‹é˜ˆå€¼ | 20% | è¶…è¿‡1/5çš„æ®µè½éœ€è¦é‡è¯•ï¼Œæ•ˆç‡å·²ç»å¾ˆä½ |
| æœ€å°æ£€æŸ¥æ®µæ•° | 5 | é¿å…å‰å‡ æ®µå¶ç„¶ä½ç½®ä¿¡åº¦å°±è§¦å‘ç†”æ–­ |

---

## ğŸš€ ä¸‹ä¸€æ­¥

1. å®ç° `demucs_service.py`
2. ä¿®æ”¹ `transcription_service.py` é›†æˆDemucs
3. æ·»åŠ å‰ç«¯è®¾ç½®ç•Œé¢
4. æ·»åŠ SSEè¿›åº¦æ¨é€ï¼ˆåˆ†ç¦»è¿›åº¦ï¼‰

---

## ğŸ“Š æ–­ç‚¹ç»­ä¼ æœºåˆ¶ä¿®æ”¹

### ç°æœ‰æœºåˆ¶å›é¡¾

å½“å‰ checkpoint.json ç»“æ„ï¼š
```json
{
  "job_id": "xxx",
  "phase": "transcribe",
  "processing_mode": "memory",
  "total_segments": 20,
  "processed_indices": [0, 1, 2, 3],
  "segments": [...],
  "unaligned_results": [...],
  "timestamp": 1234567890
}
```

### æ–°å¢å­—æ®µè®¾è®¡

```json
{
  "job_id": "xxx",
  "phase": "transcribe",
  "processing_mode": "memory",
  
  // ========== æ–°å¢ï¼šDemucsç›¸å…³å­—æ®µ ==========
  "demucs": {
    "enabled": true,
    "mode": "auto",                    // "auto" | "always" | "on_demand" | "never"
    "bgm_level": "light",              // "none" | "light" | "heavy"
    "bgm_ratios": [0.15, 0.12, 0.18],  // å„é‡‡æ ·ç‚¹çš„BGMæ¯”ä¾‹
    "global_separation_done": false,   // å…¨å±€åˆ†ç¦»æ˜¯å¦å·²å®Œæˆ
    "vocals_path": null,               // åˆ†ç¦»åçš„äººå£°æ–‡ä»¶è·¯å¾„
    "circuit_breaker": {               // ç†”æ–­å™¨çŠ¶æ€ï¼ˆç”¨äºæ¢å¤ï¼‰
      "consecutive_retries": 0,
      "total_retries": 2,
      "processed_segments": 10
    },
    "retry_triggered": false           // æ˜¯å¦å› ç†”æ–­è§¦å‘äº†å…¨å±€é‡è¯•
  },
  
  "total_segments": 20,
  "processed_indices": [0, 1, 2, 3],
  "segments": [...],
  "unaligned_results": [...],
  "timestamp": 1234567890
}
```

### é˜¶æ®µå®šä¹‰æ‰©å±•

```python
# åŸæœ‰é˜¶æ®µ
PHASES = ["pending", "extract", "split", "transcribe", "align", "srt", "complete"]

# æ–°å¢é˜¶æ®µï¼ˆæ’å…¥åˆ°æµç¨‹ä¸­ï¼‰
PHASES_WITH_DEMUCS = [
    "pending",
    "extract",          # éŸ³é¢‘æå–
    "bgm_detect",       # ã€æ–°å¢ã€‘BGMæ£€æµ‹
    "demucs_global",    # ã€æ–°å¢ã€‘å…¨å±€äººå£°åˆ†ç¦»ï¼ˆä»…Heavyæ¨¡å¼ï¼‰
    "split",            # VADåˆ†æ®µ
    "transcribe",       # è½¬å½•ï¼ˆå«æŒ‰éœ€åˆ†ç¦»é‡è¯•ï¼‰
    "align",            # å¯¹é½
    "srt",              # ç”Ÿæˆå­—å¹•
    "complete"
]
```

### æ–­ç‚¹æ¢å¤é€»è¾‘

```python
def _restore_from_checkpoint(self, checkpoint: Dict, job: JobState) -> Dict:
    """
    ä»æ£€æŸ¥ç‚¹æ¢å¤ä»»åŠ¡çŠ¶æ€ï¼ˆæ”¯æŒDemucsï¼‰
    
    Returns:
        Dict: æ¢å¤çš„çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…å«åº”ä»å“ªä¸ªé˜¶æ®µç»§ç»­
    """
    phase = checkpoint.get('phase', 'pending')
    demucs_state = checkpoint.get('demucs', {})
    
    restore_info = {
        "resume_phase": phase,
        "skip_extract": False,
        "skip_bgm_detect": False,
        "skip_demucs_global": False,
        "skip_split": False,
        "audio_source": "original",  # "original" | "vocals"
        "processed_indices": set(checkpoint.get('processed_indices', [])),
        "unaligned_results": checkpoint.get('unaligned_results', []),
        "circuit_breaker_state": None
    }
    
    # æ ¹æ®phaseå†³å®šä»å“ªé‡Œç»§ç»­
    if phase == 'bgm_detect':
        # BGMæ£€æµ‹ä¸­æ–­ï¼Œéœ€è¦é‡æ–°æ£€æµ‹
        restore_info["skip_extract"] = True
        
    elif phase == 'demucs_global':
        # å…¨å±€åˆ†ç¦»ä¸­æ–­
        restore_info["skip_extract"] = True
        restore_info["skip_bgm_detect"] = True
        if demucs_state.get('global_separation_done'):
            # åˆ†ç¦»å·²å®Œæˆï¼Œè·³è¿‡
            restore_info["skip_demucs_global"] = True
            restore_info["audio_source"] = "vocals"
            
    elif phase == 'split_complete':
        # åˆ†æ®µå®Œæˆï¼Œå‡†å¤‡è½¬å½•
        restore_info["skip_extract"] = True
        restore_info["skip_bgm_detect"] = True
        restore_info["skip_demucs_global"] = demucs_state.get('global_separation_done', False)
        restore_info["skip_split"] = True
        if demucs_state.get('vocals_path'):
            restore_info["audio_source"] = "vocals"
            
    elif phase == 'transcribe':
        # è½¬å½•ä¸­æ–­ï¼Œæ¢å¤è¿›åº¦
        restore_info["skip_extract"] = True
        restore_info["skip_bgm_detect"] = True
        restore_info["skip_demucs_global"] = True
        restore_info["skip_split"] = True
        
        # æ¢å¤ç†”æ–­å™¨çŠ¶æ€
        cb_state = demucs_state.get('circuit_breaker', {})
        if cb_state:
            restore_info["circuit_breaker_state"] = CircuitBreakerState(
                consecutive_retries=cb_state.get('consecutive_retries', 0),
                total_retries=cb_state.get('total_retries', 0),
                processed_segments=cb_state.get('processed_segments', 0),
                total_segments=checkpoint.get('total_segments', 0)
            )
        
        # åˆ¤æ–­ä½¿ç”¨å“ªä¸ªéŸ³é¢‘æº
        if demucs_state.get('vocals_path') and demucs_state.get('global_separation_done'):
            restore_info["audio_source"] = "vocals"
            
    elif phase == 'align':
        # å¯¹é½ä¸­æ–­ï¼Œéœ€è¦é‡æ–°å¯¹é½ï¼ˆå¯¹é½æ˜¯åŸå­æ“ä½œï¼‰
        restore_info["skip_extract"] = True
        restore_info["skip_bgm_detect"] = True
        restore_info["skip_demucs_global"] = True
        restore_info["skip_split"] = True
        restore_info["resume_phase"] = "align"
        
    return restore_info
```

### ç†”æ–­åçš„checkpointå¤„ç†

```python
def _handle_circuit_breaker_triggered(
    self, 
    job: JobState, 
    job_dir: Path,
    checkpoint: Dict
) -> Dict:
    """
    ç†”æ–­è§¦å‘åçš„checkpointæ›´æ–°
    
    å…³é”®ï¼šæ ‡è®°retry_triggered=Trueï¼Œæ¸…é™¤å·²æœ‰è½¬å½•ç»“æœï¼Œ
    ä½†ä¿ç•™BGMæ£€æµ‹ç»“æœï¼ˆé¿å…é‡å¤æ£€æµ‹ï¼‰
    """
    demucs_state = checkpoint.get('demucs', {})
    
    # æ›´æ–°checkpoint
    new_checkpoint = {
        "job_id": job.job_id,
        "phase": "demucs_global",  # å›é€€åˆ°å…¨å±€åˆ†ç¦»é˜¶æ®µ
        "processing_mode": checkpoint.get('processing_mode', 'memory'),
        "demucs": {
            **demucs_state,
            "bgm_level": "heavy",           # å¼ºåˆ¶å‡çº§ä¸ºHeavy
            "global_separation_done": False, # éœ€è¦æ‰§è¡Œå…¨å±€åˆ†ç¦»
            "vocals_path": None,
            "retry_triggered": True,         # æ ‡è®°æ˜¯ç†”æ–­è§¦å‘çš„
            "circuit_breaker": None          # æ¸…é™¤ç†”æ–­å™¨çŠ¶æ€
        },
        "total_segments": 0,                 # æ¸…é™¤åˆ†æ®µä¿¡æ¯
        "processed_indices": [],             # æ¸…é™¤è¿›åº¦
        "segments": [],
        "unaligned_results": [],             # æ¸…é™¤è½¬å½•ç»“æœ
        "timestamp": time.time()
    }
    
    self._save_checkpoint(job_dir, new_checkpoint, job)
    self.logger.warning("ç†”æ–­è§¦å‘ï¼Œcheckpointå·²é‡ç½®ï¼Œå°†æ‰§è¡Œå…¨å±€äººå£°åˆ†ç¦»")
    
    return new_checkpoint
```

### æ–­ç‚¹ç»­ä¼ çŠ¶æ€å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         æ–­ç‚¹ç»­ä¼ çŠ¶æ€è½¬æ¢å›¾                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  [pending] â”€â”€â–º [extract] â”€â”€â–º [bgm_detect] â”€â”€â”¬â”€â”€â–º [demucs_global] â”€â”€â”       â”‚
â”‚                                             â”‚                       â”‚       â”‚
â”‚                                             â”‚ (Light/None)          â”‚       â”‚
â”‚                                             â–¼                       â–¼       â”‚
â”‚                                       [split_complete] â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                             â”‚                               â”‚
â”‚                                             â–¼                               â”‚
â”‚                                       [transcribe] â”€â”€â”                      â”‚
â”‚                                             â”‚        â”‚                      â”‚
â”‚                                             â”‚    ç†”æ–­è§¦å‘                   â”‚
â”‚                                             â”‚        â”‚                      â”‚
â”‚                                             â”‚        â–¼                      â”‚
â”‚                                             â”‚  [demucs_global] â—„â”€â”€â”˜        â”‚
â”‚                                             â”‚   (retry_triggered=true)      â”‚
â”‚                                             â–¼                               â”‚
â”‚                                        [align]                              â”‚
â”‚                                             â”‚                               â”‚
â”‚                                             â–¼                               â”‚
â”‚                                         [srt]                               â”‚
â”‚                                             â”‚                               â”‚
â”‚                                             â–¼                               â”‚
â”‚                                       [complete]                            â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ˆ å‰ç«¯è¿›åº¦æ¡ä¿®æ”¹

### ç°æœ‰è¿›åº¦æƒé‡é…ç½®

```python
# backend/app/core/config.py
PHASE_WEIGHTS = {
    "pending": 0,
    "extract": 5,       # 5%
    "split": 5,         # 5%
    "transcribe": 60,   # 60%
    "align": 20,        # 20%
    "srt": 10,          # 10%
    "complete": 0
}
# TOTAL_WEIGHT = 100
```

### æ–°å¢Demucsé˜¶æ®µçš„æƒé‡åˆ†é…

#### æ–¹æ¡ˆAï¼šåŠ¨æ€æƒé‡ï¼ˆæ ¹æ®æ˜¯å¦éœ€è¦Demucsè°ƒæ•´ï¼‰

```python
def get_phase_weights(self, demucs_mode: str = "none") -> Dict:
    """
    æ ¹æ®Demucsæ¨¡å¼è¿”å›ä¸åŒçš„æƒé‡é…ç½®
    
    Args:
        demucs_mode: "none" | "detect_only" | "on_demand" | "global"
    """
    if demucs_mode == "none":
        # æ— Demucsï¼Œä½¿ç”¨åŸæœ‰æƒé‡
        return {
            "pending": 0,
            "extract": 5,
            "split": 5,
            "transcribe": 60,
            "align": 20,
            "srt": 10,
            "complete": 0
        }
    
    elif demucs_mode == "detect_only":
        # ä»…æ£€æµ‹ï¼ˆLight/Noneæ¨¡å¼ï¼ŒæŒ‰éœ€åˆ†ç¦»ï¼‰
        return {
            "pending": 0,
            "extract": 5,
            "bgm_detect": 5,      # ã€æ–°å¢ã€‘BGMæ£€æµ‹å 5%
            "split": 5,
            "transcribe": 55,     # é™ä½ï¼Œä¸ºæ£€æµ‹è®©å‡ºç©ºé—´
            "align": 20,
            "srt": 10,
            "complete": 0
        }
    
    elif demucs_mode == "global":
        # å…¨å±€åˆ†ç¦»ï¼ˆHeavyæ¨¡å¼æˆ–ç†”æ–­åï¼‰
        return {
            "pending": 0,
            "extract": 5,
            "bgm_detect": 3,      # BGMæ£€æµ‹å 3%
            "demucs_global": 12,  # ã€æ–°å¢ã€‘å…¨å±€åˆ†ç¦»å 12%
            "split": 5,
            "transcribe": 50,     # é™ä½ï¼Œä¸ºåˆ†ç¦»è®©å‡ºç©ºé—´
            "align": 15,          # ç•¥å¾®é™ä½
            "srt": 10,
            "complete": 0
        }
    
    else:  # "on_demand" æˆ–å…¶ä»–
        return self.get_phase_weights("detect_only")
```

#### æ–¹æ¡ˆBï¼šå›ºå®šæƒé‡ï¼ˆæ¨èï¼Œæ›´ç®€å•ï¼‰

å§‹ç»ˆé¢„ç•™Demucsçš„æƒé‡ä½ç½®ï¼Œå³ä½¿ä¸ä½¿ç”¨ä¹Ÿå¿«é€Ÿè·³è¿‡ï¼š

```python
PHASE_WEIGHTS_WITH_DEMUCS = {
    "pending": 0,
    "extract": 5,           # éŸ³é¢‘æå– 5%
    "bgm_detect": 3,        # BGMæ£€æµ‹ 3%ï¼ˆä¸ç”¨æ—¶å¿«é€Ÿè·³è¿‡ï¼‰
    "demucs_global": 7,     # å…¨å±€åˆ†ç¦» 7%ï¼ˆä¸ç”¨æ—¶å¿«é€Ÿè·³è¿‡ï¼‰
    "split": 5,             # VADåˆ†æ®µ 5%
    "transcribe": 50,       # è½¬å½• 50%
    "align": 20,            # å¯¹é½ 20%
    "srt": 10,              # ç”Ÿæˆå­—å¹• 10%
    "complete": 0
}
# TOTAL_WEIGHT = 100
```

**ä¼˜ç‚¹**ï¼šå‰ç«¯è¿›åº¦æ¡é€»è¾‘ä¸éœ€è¦æ ¹æ®æ¨¡å¼åŠ¨æ€è°ƒæ•´

### å‰ç«¯è¿›åº¦æ¡æ•°æ®ç»“æ„

```typescript
// å‰ç«¯æ¥æ”¶çš„SSEè¿›åº¦æ•°æ®
interface ProgressData {
  job_id: string;
  phase: string;           // å½“å‰é˜¶æ®µ
  percent: number;         // æ€»è¿›åº¦ (0-100)
  phase_percent: number;   // é˜¶æ®µå†…è¿›åº¦ (0-100)
  message: string;         // è¿›åº¦æ¶ˆæ¯
  status: string;
  processed: number;
  total: number;
  
  // ã€æ–°å¢ã€‘Demucsç›¸å…³
  demucs?: {
    enabled: boolean;
    mode: string;           // "auto" | "always" | "on_demand" | "never"
    bgm_level?: string;     // "none" | "light" | "heavy"ï¼ˆæ£€æµ‹åæ‰æœ‰ï¼‰
    is_separating?: boolean; // æ˜¯å¦æ­£åœ¨åˆ†ç¦»
    retry_triggered?: boolean; // æ˜¯å¦è§¦å‘äº†ç†”æ–­é‡è¯•
  };
}
```

### å‰ç«¯è¿›åº¦æ¡æ˜¾ç¤ºé€»è¾‘

```typescript
// é˜¶æ®µä¸­æ–‡åç§°æ˜ å°„ï¼ˆæ›´æ–°ï¼‰
const PHASE_NAMES: Record<string, string> = {
  pending: 'ç­‰å¾…ä¸­',
  extract: 'æå–éŸ³é¢‘',
  bgm_detect: 'æ£€æµ‹èƒŒæ™¯éŸ³ä¹',      // ã€æ–°å¢ã€‘
  demucs_global: 'åˆ†ç¦»äººå£°',        // ã€æ–°å¢ã€‘
  split: 'éŸ³é¢‘åˆ†æ®µ',
  transcribe: 'è½¬å½•ä¸­',
  align: 'å¯¹é½æ—¶é—´è½´',
  srt: 'ç”Ÿæˆå­—å¹•',
  complete: 'å®Œæˆ'
};

// è¿›åº¦æ¡é¢œè‰²ï¼ˆæ ¹æ®é˜¶æ®µï¼‰
const PHASE_COLORS: Record<string, string> = {
  pending: 'gray',
  extract: 'blue',
  bgm_detect: 'purple',            // ã€æ–°å¢ã€‘ç´«è‰²è¡¨ç¤ºæ£€æµ‹
  demucs_global: 'violet',         // ã€æ–°å¢ã€‘ç´«ç½—å…°è‰²è¡¨ç¤ºåˆ†ç¦»
  split: 'cyan',
  transcribe: 'green',
  align: 'teal',
  srt: 'orange',
  complete: 'green'
};

// æ¸²æŸ“è¿›åº¦æ¡
function renderProgress(data: ProgressData) {
  const phaseName = PHASE_NAMES[data.phase] || data.phase;
  const phaseColor = PHASE_COLORS[data.phase] || 'blue';
  
  // ç‰¹æ®Šå¤„ç†ï¼šç†”æ–­é‡è¯•æç¤º
  let extraMessage = '';
  if (data.demucs?.retry_triggered) {
    extraMessage = ' âš ï¸ æ£€æµ‹åˆ°å¼ºèƒŒæ™¯éŸ³ä¹ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ä¸ºå…¨å±€äººå£°åˆ†ç¦»';
  }
  
  return {
    percent: data.percent,
    label: `${phaseName} ${data.phase_percent.toFixed(1)}%`,
    message: data.message + extraMessage,
    color: phaseColor
  };
}
```

### è¿›åº¦æ¡è§†è§‰æ•ˆæœå»ºè®®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä»»åŠ¡è¿›åº¦                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 35%                â”‚
â”‚                                                                         â”‚
â”‚  é˜¶æ®µ: è½¬å½•ä¸­ (12/30)                                                   â”‚
â”‚  æ¶ˆæ¯: æ­£åœ¨å¤„ç†ç¬¬12æ®µ...                                                 â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€ é˜¶æ®µæ˜ç»† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ âœ“ æå–éŸ³é¢‘     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%                              â”‚    â”‚
â”‚  â”‚ âœ“ æ£€æµ‹BGM      [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%  â†’ Light                     â”‚    â”‚
â”‚  â”‚ â—‹ äººå£°åˆ†ç¦»     [            ]   -   (æŒ‰éœ€æ¨¡å¼ï¼Œè·³è¿‡)              â”‚    â”‚
â”‚  â”‚ âœ“ éŸ³é¢‘åˆ†æ®µ     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%  â†’ 30æ®µ                      â”‚    â”‚
â”‚  â”‚ â— è½¬å½•ä¸­       [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘]  40%  â†’ 12/30                     â”‚    â”‚
â”‚  â”‚ â—‹ å¯¹é½æ—¶é—´è½´   [            ]   0%                              â”‚    â”‚
â”‚  â”‚ â—‹ ç”Ÿæˆå­—å¹•     [            ]   0%                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç†”æ–­é‡è¯•æ—¶çš„è¿›åº¦æ¡å¤„ç†

```typescript
// å½“æ”¶åˆ°ç†”æ–­é‡è¯•äº‹ä»¶æ—¶
function handleCircuitBreakerTriggered(data: ProgressData) {
  // 1. æ˜¾ç¤ºæç¤ºToast
  showToast({
    type: 'warning',
    message: 'æ£€æµ‹åˆ°å¼ºèƒŒæ™¯éŸ³ä¹å¹²æ‰°ï¼Œæ­£åœ¨åˆ‡æ¢ä¸ºå…¨å±€äººå£°åˆ†ç¦»æ¨¡å¼...',
    duration: 5000
  });
  
  // 2. è¿›åº¦å›é€€ï¼ˆè§†è§‰æ•ˆæœï¼‰
  // ä»å½“å‰è¿›åº¦å¹³æ»‘å›é€€åˆ° demucs_global é˜¶æ®µçš„èµ·ç‚¹
  animateProgressTo(15);  // çº¦15%ï¼ˆextract + bgm_detectå®Œæˆåï¼‰
  
  // 3. æ›´æ–°é˜¶æ®µæ˜¾ç¤º
  updatePhaseDisplay('demucs_global', 'åˆ†ç¦»äººå£°ï¼ˆè‡ªåŠ¨åˆ‡æ¢ï¼‰');
}
```

---

## ğŸ”„ SSEäº‹ä»¶ç±»å‹æ‰©å±•

### æ–°å¢äº‹ä»¶ç±»å‹

```python
# ç°æœ‰äº‹ä»¶
SSE_EVENTS = [
    "connected",      # è¿æ¥å»ºç«‹
    "progress",       # è¿›åº¦æ›´æ–°
    "segment",        # å•æ®µè½¬å½•å®Œæˆ
    "aligned",        # å¯¹é½å®Œæˆ
    "error",          # é”™è¯¯
    "job_complete",   # ä»»åŠ¡å®Œæˆ
    "job_canceled",   # ä»»åŠ¡å–æ¶ˆ
    "job_paused",     # ä»»åŠ¡æš‚åœ
]

# æ–°å¢Demucsç›¸å…³äº‹ä»¶
SSE_EVENTS_DEMUCS = [
    "bgm_detected",           # BGMæ£€æµ‹å®Œæˆ
    "demucs_start",           # å¼€å§‹äººå£°åˆ†ç¦»
    "demucs_progress",        # åˆ†ç¦»è¿›åº¦
    "demucs_complete",        # åˆ†ç¦»å®Œæˆ
    "circuit_breaker_triggered",  # ç†”æ–­è§¦å‘
]
```

### äº‹ä»¶æ•°æ®ç»“æ„

```python
# BGMæ£€æµ‹å®Œæˆäº‹ä»¶
{
    "type": "bgm_detected",
    "data": {
        "level": "light",           # "none" | "light" | "heavy"
        "ratios": [0.15, 0.12, 0.18],
        "max_ratio": 0.18,
        "recommendation": "on_demand"  # å»ºè®®çš„å¤„ç†æ¨¡å¼
    }
}

# åˆ†ç¦»è¿›åº¦äº‹ä»¶
{
    "type": "demucs_progress",
    "data": {
        "mode": "global",           # "global" | "segment"
        "progress": 0.45,           # 0-1
        "message": "åˆ†ç¦»ä¸­ 45%...",
        "segment_index": null       # ä»…segmentæ¨¡å¼æœ‰å€¼
    }
}

# ç†”æ–­è§¦å‘äº‹ä»¶
{
    "type": "circuit_breaker_triggered",
    "data": {
        "reason": "consecutive",     # "consecutive" | "ratio"
        "stats": {
            "consecutive_retries": 3,
            "total_retries": 5,
            "retry_ratio": 0.25
        },
        "action": "å‡çº§ä¸ºå…¨å±€äººå£°åˆ†ç¦»æ¨¡å¼",
        "estimated_extra_time": 120  # é¢„ä¼°é¢å¤–è€—æ—¶ï¼ˆç§’ï¼‰
    }
}
```

---

## ğŸ“ æ–‡ä»¶å˜æ›´æ¸…å•ï¼ˆæ›´æ–°ï¼‰

### æ–°å¢æ–‡ä»¶

| æ–‡ä»¶ | è¯´æ˜ |
|------|------|
| `backend/app/services/demucs_service.py` | Demucsäººå£°åˆ†ç¦»æœåŠ¡ |
| `docs/Demucsäººå£°åˆ†ç¦»é›†æˆæ–¹æ¡ˆ.md` | æœ¬æ–‡æ¡£ |

### ä¿®æ”¹æ–‡ä»¶

| æ–‡ä»¶ | ä¿®æ”¹å†…å®¹ |
|------|----------|
| `backend/app/services/transcription_service.py` | æ·»åŠ Demucsé›†æˆé€»è¾‘ã€ç†”æ–­æœºåˆ¶ã€checkpointæ‰©å±• |
| `backend/app/core/config.py` | æ·»åŠ æ–°çš„PHASE_WEIGHTSé…ç½® |
| `backend/requirements.txt` | æ·»åŠ  `demucs>=4.0.0` |
| `frontend/src/components/TaskProgress.vue` | æ›´æ–°è¿›åº¦æ¡æ˜¾ç¤ºé€»è¾‘ |
| `frontend/src/types/progress.ts` | æ·»åŠ Demucsç›¸å…³ç±»å‹å®šä¹‰ |
